<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CholeskyDecomposer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-algebra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.algebra</a> &gt; <span class="el_source">CholeskyDecomposer.java</span></div><h1>CholeskyDecomposer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.algebra;

/**
 * This class allows decomposition of matrices using Cholesky decomposition,
 * which consists on retrieving a lower or upper triangular matrix so that input
 * matrix can be decomposed as: A = L * L' = R' * R, where A is provided input
 * matrix, L is a lower triangular matrix and R is an upper triangular matrix.
 * Note: Cholesky decomposition can only be correctly computed on positive
 * definite matrices.
 */
public class CholeskyDecomposer extends Decomposer {

    /**
     * Internal storage of Cholesky decomposition for provided input matrix.
     */
    private Matrix r;

    /**
     * Boolean indicating whether provided input matrix is symmetric and
     * positive definite.
     */
    private boolean spd;

    /**
     * Constructor of this class.
     */
    public CholeskyDecomposer() {
<span class="fc" id="L43">        super();</span>
<span class="fc" id="L44">        r = null;</span>
<span class="fc" id="L45">        spd = false;</span>
<span class="fc" id="L46">    }</span>

    /**
     * Constructor of this class.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     */
    public CholeskyDecomposer(final Matrix inputMatrix) {
<span class="fc" id="L54">        super(inputMatrix);</span>
<span class="fc" id="L55">        r = null;</span>
<span class="fc" id="L56">        spd = false;</span>
<span class="fc" id="L57">    }</span>

    /**
     * Returns decomposer type corresponding to Cholesky decomposition.
     *
     * @return Decomposer type.
     */
    @Override
    public DecomposerType getDecomposerType() {
<span class="fc" id="L66">        return DecomposerType.CHOLESKY_DECOMPOSITION;</span>
    }

    /**
     * Sets reference to input matrix to be decomposed.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     * @throws LockedException Exception thrown if attempting to call this
     *                         method while this instance remains locked.
     */
    @Override
    public void setInputMatrix(final Matrix inputMatrix) throws LockedException {
<span class="fc" id="L78">        super.setInputMatrix(inputMatrix);</span>
<span class="fc" id="L79">        r = null;</span>
<span class="fc" id="L80">        spd = false;</span>
<span class="fc" id="L81">    }</span>


    /**
     * Returns boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     * Attempting to retrieve decomposition results when not available, will
     * probably raise a NotAvailableException.
     *
     * @return Boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     */
    @Override
    public boolean isDecompositionAvailable() {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        return r != null;</span>
    }

    /**
     * This method computes Cholesky matrix decomposition, which consists on
     * factoring provided input matrix whenever it is square, symmetric and
     * positive definite into a lower triangulator factor such that it follows
     * next expression: A = L * L'
     * where A is input matrix and L is lower triangular factor (L' is its
     * transposed).
     * Cholesky decomposition can also be computed using Right Cholesky
     * decomposition, in which case A = R' * R, where R is an upper triangular
     * factor equal to L'.
     * Both factors L and R will be accessible once Cholesky decomposition has
     * been computed.
     * Note: During execution of this method, this instance will remain locked,
     * and hence attempting to set some parameters might raise a LockedException
     * Note: After execution of this method, Cholesky decomposition will be
     * available and operations such as retrieving L matrix factor or solving
     * systems of linear equations will be able to be done. Attempting to call
     * any of such operations before calling this method will raise a
     * NotAvailableException because they require computation of Cholesky
     * decomposition first.
     *
     * @throws NotReadyException   Exception thrown if attempting to call this
     *                             method when this instance is not ready (i.e. no input matrix has been
     *                             provided).
     * @throws LockedException     Exception thrown if this decomposer is already
     *                             locked before calling this method. Notice that this method will actually
     *                             lock this instance while it is being executed.
     * @throws DecomposerException Exception thrown if for any reason
     *                             decomposition fails while being executed, like when convergence of
     *                             results cannot be obtained, etc.
     */
    @Override
    public void decompose() throws NotReadyException, LockedException, DecomposerException {

<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L133">            throw new LockedException();</span>
        }

<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L137">            throw new NotReadyException();</span>
        }

<span class="fc" id="L140">        final var rows = inputMatrix.getRows();</span>
<span class="fc" id="L141">        final var columns = inputMatrix.getColumns();</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">        if (rows != columns) {</span>
<span class="fc" id="L144">            throw new DecomposerException();</span>
        }

<span class="fc" id="L147">        locked = true;</span>

        final Matrix localR;
        try {
<span class="fc" id="L151">            localR = new Matrix(columns, columns);</span>
<span class="nc" id="L152">        } catch (WrongSizeException e) {</span>
<span class="nc" id="L153">            throw new DecomposerException(e);</span>
<span class="fc" id="L154">        }</span>

<span class="fc" id="L156">        var localSpd = true;</span>
        double d;
        double s;

        // Main loop
<span class="fc bfc" id="L161" title="All 2 branches covered.">        for (var j = 0; j &lt; columns; j++) {</span>
<span class="fc" id="L162">            d = 0.0;</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">            for (var k = 0; k &lt; j; k++) {</span>
<span class="fc" id="L164">                s = inputMatrix.getElementAt(k, j);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                for (var i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L166">                    s = s - localR.getElementAt(i, k) * localR.getElementAt(i, j);</span>
                }
<span class="fc" id="L168">                s /= localR.getElementAt(k, k);</span>
<span class="fc" id="L169">                localR.setElementAt(k, j, s);</span>
<span class="fc" id="L170">                d += s * s;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                localSpd &amp;= inputMatrix.getElementAt(k, j) == inputMatrix.getElementAt(j, k);</span>
            }
<span class="fc" id="L173">            d = inputMatrix.getElementAt(j, j) - d;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            localSpd &amp;= d &gt; 0.0;</span>
            // sqrt of max(d, 0.0)
<span class="fc" id="L176">            localR.setElementAt(j, j, Math.sqrt(Math.max(d, 0.0)));</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (var k = j + 1; k &lt; columns; k++) {</span>
<span class="fc" id="L178">                localR.setElementAt(k, j, 0.0);</span>
            }
        }

<span class="fc" id="L182">        this.spd = localSpd;</span>
<span class="fc" id="L183">        this.r = localR;</span>

<span class="fc" id="L185">        locked = false;</span>
<span class="fc" id="L186">    }</span>

    /**
     * Returns Cholesky matrix factor corresponding to a Lower triangular matrix
     * following this expression: A = L * L'. Where A is provided input matrix
     * that has been decomposed and L is the left lower triangular matrix
     * factor.
     *
     * @return Returns Cholesky Lower triangular matrix
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before actually computing Cholesky decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getL() throws NotAvailableException {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L202">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L205">        return r.transposeAndReturnNew();</span>
    }

    /**
     * Returns Cholesky matrix factor corresponding to an upper triangular
     * matrix following this expression: A = R' * R. Where A is provided input
     * matrix that has been decomposed and R is the right upper triangular
     * matrix factor.
     *
     * @return Returns Cholesky upper triangular matrix
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before actually computing Cholesky decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getR() throws NotAvailableException {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L222">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L225">        return r;</span>
    }

    /**
     * Returns boolean indicating whether provided input matrix is
     * Symmetric Positive Definite or not.
     * Notice that if returned value is false, then Cholesky decomposition
     * should be ignored, as Cholesky decomposition can only be computed on
     * symmetric positive definite matrices.
     *
     * @return Boolean indicating whether provided input matrix is symmetric
     * positive definite or not.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Cholesky decomposition. To avoid this exception
     *                               call decompose() method first.
     * @see #decompose()
     */
    public boolean isSPD() throws NotAvailableException {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L244">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L247">        return spd;</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B.
     * Where A is the input matrix provided for Cholesky decomposition, X is the
     * solution to the system of equations, and B is the parameters
     * vector/matrix.
     * Note: This method can be reused for different b vectors/matrices without
     * having to recompute Cholesky decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise an IllegalArgumentException will be raised
     * Note: Provided input matrix A must be square, otherwise a
     * WrongSizeException will be raised.
     * Note: If provided input matrix A is not symmetric positive definite, a
     * NonSymmetricPositiveDefiniteMatrixException will be thrown.
     * Note: In order to be able to execute this method, a Cholesky
     * decomposition must be available, otherwise a NotAvailableException will
     * be raised. In order to avoid this exception call decompose() method first
     * Note: result matrix contains solution of linear system of equations. It
     * will be resized if provided matrix does not have proper size
     *
     * @param b      Parameters of linear system of equations
     * @param result instance where solution X will be stored.
     * @throws com.irurueta.algebra.NotAvailableException                       if decomposition has
     *                                                                          not yet been computed.
     * @throws com.irurueta.algebra.WrongSizeException                          if the number of rows of
     *                                                                          b matrix is not equal to the number of rows of input matrix provided to
     *                                                                          Cholesky decomposer.
     * @throws com.irurueta.algebra.NonSymmetricPositiveDefiniteMatrixException if input matrix provided to Cholesky decomposer is not positive definite.
     */
    public void solve(final Matrix b, final Matrix result) throws NotAvailableException, WrongSizeException,
            NonSymmetricPositiveDefiniteMatrixException {

<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L282">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L285">        final var rows = inputMatrix.getRows();</span>
<span class="fc" id="L286">        final var columns = inputMatrix.getColumns();</span>
<span class="fc" id="L287">        final var rowsB = b.getRows();</span>
<span class="fc" id="L288">        final var colsB = b.getColumns();</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (rowsB != rows) {</span>
<span class="fc" id="L291">            throw new WrongSizeException();</span>
        }

<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (!isSPD()) {</span>
<span class="fc" id="L295">            throw new NonSymmetricPositiveDefiniteMatrixException();</span>
        }

        // resize result matrix if needed
<span class="pc bpc" id="L299" title="2 of 4 branches missed.">        if (result.getRows() != rowsB || result.getColumns() != colsB) {</span>
<span class="nc" id="L300">            result.resize(rowsB, colsB);</span>
        }

        // Copy b into result matrix
<span class="fc" id="L304">        result.copyFrom(b);</span>

<span class="fc" id="L306">        final var l = getL();</span>

        // Solve L * Y = B
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (var k = 0; k &lt; columns; k++) {</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">            for (var j = 0; j &lt; colsB; j++) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">                for (var i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L312">                    result.setElementAt(k, j, result.getElementAt(k, j)</span>
<span class="fc" id="L313">                            - result.getElementAt(i, j) * l.getElementAt(k, i));</span>
                }
<span class="fc" id="L315">                result.setElementAt(k, j, result.getElementAt(k, j) / l.getElementAt(k, k));</span>
            }
        }

        // Solve L' * X = Y
        int k2;
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (var k = columns - 1; k &gt;= 0; k--) {</span>
<span class="fc" id="L322">            k2 = k;</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">            for (var j = 0; j &lt; colsB; j++) {</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">                for (var i = k2 + 1; i &lt; columns; i++) {</span>
<span class="fc" id="L325">                    result.setElementAt(k2, j, result.getElementAt(k2, j)</span>
<span class="fc" id="L326">                            - result.getElementAt(i, j) * l.getElementAt(i, k2));</span>
                }
<span class="fc" id="L328">                result.setElementAt(k2, j, result.getElementAt(k2, j) / l.getElementAt(k2, k2));</span>
            }
        }
<span class="fc" id="L331">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B.
     * Where A is the input matrix provided for Cholesky decomposition, X is the
     * solution to the system of equations, and B is the parameters
     * vector/matrix.
     * Note: This method can be reused for different b vectors/matrices without
     * having to recompute Cholesky decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise an IllegalArgumentException will be raised
     * Note: Provided input matrix A must be square, otherwise a
     * WrongSizeException will be raised.
     * Note: If provided input matrix A is not symmetric positive definite, a
     * NonSymmetricPositiveDefiniteMatrixException will be thrown.
     * Note: In order to be able to execute this method, a Cholesky
     * decomposition must be available, otherwise a NotAvailableException will
     * be raised. In order to avoid this exception call decompose() method first
     *
     * @param b Parameters of linear system of equations
     * @return a new matrix containing solution X.
     * @throws com.irurueta.algebra.NotAvailableException                       if decomposition has
     *                                                                          not yet been computed.
     * @throws com.irurueta.algebra.WrongSizeException                          if the number of rows of
     *                                                                          b matrix is not equal to the number of rows of input matrix provided to
     *                                                                          Cholesky decomposer.
     * @throws com.irurueta.algebra.NonSymmetricPositiveDefiniteMatrixException if input matrix provided to Cholesky decomposer is not positive definite.
     */
    public Matrix solve(final Matrix b) throws NotAvailableException, WrongSizeException,
            NonSymmetricPositiveDefiniteMatrixException {

<span class="fc" id="L362">        final var columns = inputMatrix.getColumns();</span>
<span class="fc" id="L363">        final var colsB = b.getColumns();</span>
<span class="fc" id="L364">        final var out = new Matrix(columns, colsB);</span>
<span class="fc" id="L365">        solve(b, out);</span>
<span class="fc" id="L366">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>