<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ArrayUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-algebra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.algebra</a> &gt; <span class="el_source">ArrayUtils.java</span></div><h1>ArrayUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.algebra;

import java.util.Arrays;

/**
 * Class containing utility methods for common operations with arrays of values.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class ArrayUtils {

    /**
     * Constructor.
     */
    private ArrayUtils() {
    }

    /**
     * Internal method that multiplied by scalar provided input array without
     * comparing length of input array and result array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @param result     Array where result is stored.
     * @see #multiplyByScalar(double[], double, double[])
     */
    private static void internalMultiplyByScalar(
            final double[] inputArray, final double scalar, final double[] result) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (var i = 0; i &lt; inputArray.length; ++i) {</span>
<span class="fc" id="L44">            result[i] = scalar * inputArray[i];</span>
        }
<span class="fc" id="L46">    }</span>

    /**
     * Multiplies values in provided input array by provided scalar value
     * and stores the result in provided result array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @param result     Array where result is stored.
     * @throws IllegalArgumentException Thrown if inputArray length and result
     *                                  array length are not equal.
     */
    public static void multiplyByScalar(final double[] inputArray, final double scalar, final double[] result) {
<span class="fc bfc" id="L59" title="All 2 branches covered.">        if (inputArray.length != result.length) {</span>
<span class="fc" id="L60">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L62">        internalMultiplyByScalar(inputArray, scalar, result);</span>
<span class="fc" id="L63">    }</span>

    /**
     * Multiplies values in provided array by provided scalar value and returns
     * the result in a new array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @return Result obtained after multiplying input array by provided scalar
     * value.
     */
    public static double[] multiplyByScalarAndReturnNew(final double[] inputArray, final double scalar) {
<span class="fc" id="L75">        final var result = new double[inputArray.length];</span>
<span class="fc" id="L76">        internalMultiplyByScalar(inputArray, scalar, result);</span>
<span class="fc" id="L77">        return result;</span>
    }

    /**
     * Sums provided operands arrays and stores the result in provided result
     * array (i.e. result = firstOperand + secondOperand). Summation is done in
     * an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     * This method does not check array lengths.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of summation.
     */
    private static void internalSum(final double[] firstOperand, final double[] secondOperand, final double[] result) {
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L94">            result[i] = firstOperand[i] + secondOperand[i];</span>
        }
<span class="fc" id="L96">    }</span>

    /**
     * Sums provided operands arrays and stores the result in provided result
     * array (i.e. result = firstOperand + secondOperand). Summation is done
     * in an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of summation.
     * @throws IllegalArgumentException Raised if not all arrays have the same
     *                                  length.
     */
    public static void sum(final double[] firstOperand, final double[] secondOperand, final double[] result) {
<span class="pc bpc" id="L112" title="1 of 4 branches missed.">        if (firstOperand.length != secondOperand.length || firstOperand.length != result.length) {</span>
<span class="fc" id="L113">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L115">        internalSum(firstOperand, secondOperand, result);</span>
<span class="fc" id="L116">    }</span>

    /**
     * Sums provided operands and returns the result as a new array instance.
     * Summation is done in an element by element basis.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @return Sum of first and second operands.
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length.
     */
    public static double[] sumAndReturnNew(final double[] firstOperand, final double[] secondOperand) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L130">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L133">        final var result = new double[firstOperand.length];</span>
<span class="fc" id="L134">        internalSum(firstOperand, secondOperand, result);</span>
<span class="fc" id="L135">        return result;</span>
    }

    /**
     * Subtracts provided operands arrays and stores the result in provided
     * result array (i.e. result = firstOperand - secondOperand). Subtraction is
     * done in an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     * This method does not check array lengths.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of subtraction.
     */
    private static void internalSubtract(
            final double[] firstOperand, final double[] secondOperand, final double[] result) {
<span class="fc bfc" id="L152" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L153">            result[i] = firstOperand[i] - secondOperand[i];</span>
        }
<span class="fc" id="L155">    }</span>

    /**
     * Subtracts provided operands arrays and stores the result in provided
     * result array (i.e. result = firstOperand - secondOperand). Subtraction is
     * done in an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of subtraction.
     * @throws IllegalArgumentException Raised if not all arrays have the same
     *                                  length.
     */
    public static void subtract(final double[] firstOperand, final double[] secondOperand, final double[] result) {
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">        if (firstOperand.length != secondOperand.length || firstOperand.length != result.length) {</span>
<span class="fc" id="L172">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L174">        internalSubtract(firstOperand, secondOperand, result);</span>
<span class="fc" id="L175">    }</span>

    /**
     * Subtracts provided operands and returns the result as a new array
     * instance.
     * Subtraction is done in an element by element basis.
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @return Subtraction of first and second operands
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length
     */
    public static double[] subtractAndReturnNew(final double[] firstOperand, final double[] secondOperand) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L190">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L193">        final var result = new double[firstOperand.length];</span>
<span class="fc" id="L194">        internalSubtract(firstOperand, secondOperand, result);</span>
<span class="fc" id="L195">        return result;</span>
    }

    /**
     * Computes the dot product of provided arrays as the sum of the product
     * of the elements of both arrays.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @return Dot product.
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length.
     */
    public static double dotProduct(final double[] firstOperand, final double[] secondOperand) {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L210">            throw new IllegalArgumentException(&quot;both operands must have same length&quot;);</span>
        }

<span class="fc" id="L213">        var result = 0.0;</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L215">            result += firstOperand[i] * secondOperand[i];</span>
        }
<span class="fc" id="L217">        return result;</span>
    }

    /**
     * Computes the dot product of provided arrays as the sum of the product of
     * the elements of both arrays.
     *
     * @param firstOperand   first operand.
     * @param secondOperand  second operand.
     * @param jacobianFirst  matrix where jacobian of first operand will be
     *                       stored. Must be a column matrix having the same number of rows as the
     *                       first operand length.
     * @param jacobianSecond matrix where jacobian of second operand will be
     *                       stored. Must be a column matrix having the same number of rows as the
     *                       second operand length.
     * @return dot product.
     * @throws IllegalArgumentException if first and second operands don't have
     *                                  the same length or if jacobian matrices are not column vectors having
     *                                  the same length as their respective operands.
     */
    public static double dotProduct(final double[] firstOperand, final double[] secondOperand,
                                    final Matrix jacobianFirst, final Matrix jacobianSecond) {
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (jacobianFirst != null</span>
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">                &amp;&amp; (jacobianFirst.getRows() != 1 || jacobianFirst.getColumns() != firstOperand.length)) {</span>
<span class="fc" id="L241">            throw new IllegalArgumentException(&quot;jacobian first must be a row vector having the same number of &quot;</span>
                    + &quot;columns as first operand length&quot;);
        }
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (jacobianSecond != null</span>
<span class="pc bpc" id="L245" title="1 of 4 branches missed.">                &amp;&amp; (jacobianSecond.getRows() != 1 || jacobianSecond.getColumns() != secondOperand.length)) {</span>
<span class="fc" id="L246">            throw new IllegalArgumentException(&quot;jacobian second must be a row vector having the same number of &quot;</span>
                    + &quot;columns as second operand length&quot;);
        }

<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (jacobianFirst != null) {</span>
<span class="fc" id="L251">            jacobianFirst.setSubmatrix(0, 0, 0,</span>
                    firstOperand.length - 1, firstOperand);
        }
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (jacobianSecond != null) {</span>
<span class="fc" id="L255">            jacobianSecond.setSubmatrix(0, 0, 0,</span>
                    secondOperand.length - 1, secondOperand);
        }

<span class="fc" id="L259">        return dotProduct(firstOperand, secondOperand);</span>
    }

    /**
     * Computes the angle between two vectors.
     * The angle is defined between 0 and PI.
     *
     * @param firstOperand  first operand.
     * @param secondOperand second operand.
     * @return angle between arrays.
     * @throws IllegalArgumentException if first and second operands don't have
     *                                  the same length.
     */
    public static double angle(final double[] firstOperand, final double[] secondOperand) {
<span class="fc" id="L273">        final var norm1 = Utils.normF(firstOperand);</span>
<span class="fc" id="L274">        final var norm2 = Utils.normF(secondOperand);</span>
<span class="fc" id="L275">        return Math.acos(Math.min(dotProduct(firstOperand, secondOperand) / norm1 / norm2, 1.0));</span>
    }

    //The same for Complex arrays

    /**
     * Internal method that multiplied by scalar provided input array without
     * comparing length of input array and result array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @param result     Array where result is stored.
     * @see #multiplyByScalar(double[], double, double[])
     */
    private static void internalMultiplyByScalar(final Complex[] inputArray, final double scalar,
                                                 final Complex[] result) {
<span class="fc bfc" id="L291" title="All 2 branches covered.">        for (var i = 0; i &lt; inputArray.length; ++i) {</span>
<span class="fc" id="L292">            result[i].setReal(inputArray[i].getReal() * scalar);</span>
<span class="fc" id="L293">            result[i].setImaginary(inputArray[i].getImaginary() * scalar);</span>
        }
<span class="fc" id="L295">    }</span>

    /**
     * Multiplies values in provided input array by provided scalar value
     * and stores the result in provided result array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @param result     Array where result is stored.
     * @throws IllegalArgumentException Thrown if inputArray length and result
     *                                  array length are not equal.
     */
    public static void multiplyByScalar(final Complex[] inputArray, final double scalar, final Complex[] result) {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (inputArray.length != result.length) {</span>
<span class="fc" id="L309">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L311">        internalMultiplyByScalar(inputArray, scalar, result);</span>
<span class="fc" id="L312">    }</span>

    /**
     * Multiplies values in provided array by provided scalar value and returns
     * the result in a new array.
     *
     * @param inputArray Array to be multiplied.
     * @param scalar     Scalar used for multiplication.
     * @return Result obtained after multiplying input array by provided scalar
     * value.
     */
    public static Complex[] multiplyByScalarAndReturnNew(final Complex[] inputArray, final double scalar) {
<span class="fc" id="L324">        final var result = new Complex[inputArray.length];</span>
        // instantiate Complex instances in result array containing values of
        // provided array multiplied by scalar value
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (var i = 0; i &lt; inputArray.length; i++) {</span>
<span class="fc" id="L328">            result[i] = new Complex(inputArray[i].getReal() * scalar,</span>
<span class="fc" id="L329">                    inputArray[i].getImaginary() * scalar);</span>
        }
<span class="fc" id="L331">        return result;</span>
    }

    /**
     * Sums provided operands arrays and stores the result in provided result
     * array (i.e. result = firstOperand + secondOperand). Summation is done in
     * an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     * This method does not check array lengths.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of summation.
     */
    private static void internalSum(final Complex[] firstOperand, final Complex[] secondOperand,
                                    final Complex[] result) {
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L349">            result[i].setReal(firstOperand[i].getReal() + secondOperand[i].getReal());</span>
<span class="fc" id="L350">            result[i].setImaginary(firstOperand[i].getImaginary() + secondOperand[i].getImaginary());</span>
        }
<span class="fc" id="L352">    }</span>

    /**
     * Sums provided operands arrays and stores the result in provided result
     * array (i.e. result = firstOperand + secondOperand). Summation is done
     * in an element by element basis.
     * Provided array result must be initialized.
     * All arrays must have the same length.
     *
     * @param firstOperand  First operand.
     * @param secondOperand Second operand.
     * @param result        Result of summation.
     * @throws IllegalArgumentException Raised if not all arrays have the same
     *                                  length.
     */
    public static void sum(
            final Complex[] firstOperand, final Complex[] secondOperand, final Complex[] result) {
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">        if (firstOperand.length != secondOperand.length || firstOperand.length != result.length) {</span>
<span class="fc" id="L370">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L372">        internalSum(firstOperand, secondOperand, result);</span>
<span class="fc" id="L373">    }</span>

    /**
     * Sums provided operands and returns the result as a new array instance.
     * Summation is done in an element by element basis
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @return Sum of first and second operands
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length
     */
    public static Complex[] sumAndReturnNew(final Complex[] firstOperand, final Complex[] secondOperand) {
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L387">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L390">        final var result = new Complex[firstOperand.length];</span>
        // initialize each element of result matrix
<span class="fc bfc" id="L392" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++)</span>
<span class="fc" id="L393">            result[i] = firstOperand[i].addAndReturnNew(secondOperand[i]);</span>
<span class="fc" id="L394">        return result;</span>
    }

    /**
     * Subtracts provided operands arrays and stores the result in provided
     * result array (i.e. result = firstOperand - secondOperand). Subtraction is
     * done in an element by element basis
     * Provided array result must be initialized.
     * All arrays must have the same length
     * This method does not check array lengths
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @param result        Result of subtraction
     */
    private static void internalSubtract(
            final Complex[] firstOperand, final Complex[] secondOperand, final Complex[] result) {
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L412">            result[i].setReal(firstOperand[i].getReal() - secondOperand[i].getReal());</span>
<span class="fc" id="L413">            result[i].setImaginary(firstOperand[i].getImaginary() - secondOperand[i].getImaginary());</span>
        }
<span class="fc" id="L415">    }</span>

    /**
     * Subtracts provided operands arrays and stores the result in provided
     * result array (i.e. result = firstOperand - secondOperand). Subtraction is
     * done in an element by element basis
     * Provided array result must be initialized.
     * All arrays must have the same length
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @param result        Result of subtraction
     * @throws IllegalArgumentException Raised if not all arrays have the same
     *                                  length
     */
    public static void subtract(final Complex[] firstOperand, final Complex[] secondOperand, final Complex[] result) {
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        if (firstOperand.length != secondOperand.length || firstOperand.length != result.length) {</span>
<span class="fc" id="L432">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L434">        internalSubtract(firstOperand, secondOperand, result);</span>
<span class="fc" id="L435">    }</span>

    /**
     * Subtracts provided operands and returns the result as a new array
     * instance.
     * Subtraction is done in an element by element basis
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @return Subtraction of first and second operands
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length
     */
    public static Complex[] subtractAndReturnNew(final Complex[] firstOperand, final Complex[] secondOperand) {
<span class="fc bfc" id="L449" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L450">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L453">        final var result = new Complex[firstOperand.length];</span>
        // initialize each element of result matrix
<span class="fc bfc" id="L455" title="All 2 branches covered.">        for (int i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L456">            result[i] = firstOperand[i].subtractAndReturnNew(secondOperand[i]);</span>
        }
<span class="fc" id="L458">        return result;</span>
    }

    /**
     * Computes the dot product of provided arrays as the sum of the product
     * of the elements of both arrays
     *
     * @param firstOperand  First operand
     * @param secondOperand Second operand
     * @return Dot product
     * @throws IllegalArgumentException Raised if first and second operands
     *                                  arrays don't have the same length
     */
    public static Complex dotProduct(final Complex[] firstOperand, final Complex[] secondOperand) {
<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (firstOperand.length != secondOperand.length) {</span>
<span class="fc" id="L473">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L476">        final var result = new Complex(0.0);</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for (var i = 0; i &lt; firstOperand.length; i++) {</span>
<span class="fc" id="L478">            result.add(firstOperand[i].multiplyAndReturnNew(secondOperand[i]));</span>
        }
<span class="fc" id="L480">        return result;</span>
    }

    /**
     * Normalizes provided array and computes corresponding jacobian.
     *
     * @param v        array to be normalized.
     * @param result   array where result of normalized array will be stored.
     * @param jacobian matrix where jacobian will be stored.
     * @throws IllegalArgumentException if provided arrays don't have the same
     *                                  length or if provided jacobian is not NxN, where N is length of arrays.
     */
    public static void normalize(final double[] v, final double[] result, final Matrix jacobian) {
<span class="fc" id="L493">        final var s = v.length;</span>

<span class="fc bfc" id="L495" title="All 2 branches covered.">        if (s != result.length) {</span>
<span class="fc" id="L496">            throw new IllegalArgumentException(&quot;both arrays must have the same length&quot;);</span>
        }

<span class="pc bpc" id="L499" title="1 of 6 branches missed.">        if (jacobian != null &amp;&amp; (jacobian.getRows() != s || jacobian.getColumns() != s)) {</span>
<span class="fc" id="L500">            throw new IllegalArgumentException(&quot;provided jacobian is not NxN where N is length of v&quot;);</span>
        }

<span class="fc" id="L503">        final var n2 = dotProduct(v, v);</span>
<span class="fc" id="L504">        final var n = Math.sqrt(n2);</span>

<span class="fc bfc" id="L506" title="All 2 branches covered.">        if (jacobian != null) {</span>
            try {
<span class="fc" id="L508">                final var n3 = n * n2;</span>

                // VN_v = (n2*eye(s) - v*v') / n3
<span class="fc" id="L511">                Matrix.identity(jacobian);</span>
<span class="fc" id="L512">                jacobian.multiplyByScalar(n2);</span>
<span class="fc" id="L513">                jacobian.subtract(Matrix.newFromArray(v, true)</span>
<span class="fc" id="L514">                        .multiplyAndReturnNew(Matrix.newFromArray(v, false)));</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">                if (n3 != 0.0) {</span>
<span class="fc" id="L516">                    jacobian.multiplyByScalar(1.0 / n3);</span>
                } else {
<span class="fc" id="L518">                    jacobian.initialize(Double.MAX_VALUE);</span>
                }
<span class="nc" id="L520">            } catch (final WrongSizeException ignore) {</span>
                // never thrown
<span class="fc" id="L522">            }</span>
        }

<span class="fc bfc" id="L525" title="All 2 branches covered.">        if (n != 0.0) {</span>
<span class="fc" id="L526">            internalMultiplyByScalar(v, 1.0 / n, result);</span>
        } else {
<span class="fc" id="L528">            Arrays.fill(result, Double.MAX_VALUE);</span>
        }
<span class="fc" id="L530">    }</span>

    /**
     * Normalizes provided array and computes corresponding jacobian.
     *
     * @param v        array to be normalized.
     * @param jacobian matrix where jacobian will be stored.
     * @return a new array instance containing normalized array.
     * @throws IllegalArgumentException if provided jacobian is not NxN, where N
     *                                  is length of arrays.
     */
    public static double[] normalizeAndReturnNew(final double[] v, final Matrix jacobian) {
<span class="fc" id="L542">        final var result = new double[v.length];</span>
<span class="fc" id="L543">        normalize(v, result, jacobian);</span>
<span class="fc" id="L544">        return result;</span>
    }

    /**
     * Normalizes provided array, updates its values and computes corresponding
     * jacobian.
     *
     * @param v        array to be normalized and updated.
     * @param jacobian matrix where jacobian will be stored.
     * @throws IllegalArgumentException if provided jacobian is not NxN, where N
     *                                  is length of arrays.
     */
    public static void normalize(final double[] v, final Matrix jacobian) {
<span class="fc" id="L557">        normalize(v, v, jacobian);</span>
<span class="fc" id="L558">    }</span>

    /**
     * Normalizes provided array.
     *
     * @param v      array to be normalized.
     * @param result array where result of normalized array will be stored.
     * @throws IllegalArgumentException if provided arrays don't have the same
     *                                  length.
     */
    public static void normalize(final double[] v, final double[] result) {
<span class="fc" id="L569">        normalize(v, result, null);</span>
<span class="fc" id="L570">    }</span>

    /**
     * Normalizes provided array.
     *
     * @param v array to be normalized.
     * @return a new array instance containing normalized array.
     */
    public static double[] normalizeAndReturnNew(final double[] v) {
<span class="fc" id="L579">        return normalizeAndReturnNew(v, null);</span>
    }

    /**
     * Normalizes provided array and updates its values.
     *
     * @param v array to be normalized and updated.
     */
    public static void normalize(final double[] v) {
<span class="fc" id="L588">        normalize(v, (Matrix) null);</span>
<span class="fc" id="L589">    }</span>

    /**
     * Reverses the order of elements in the array.
     *
     * @param v      array to be reversed.
     * @param result instance where results will be stored.
     * @throws IllegalArgumentException if provided arrays don't have the same
     *                                  length.
     */
    public static void reverse(final double[] v, final double[] result) {

<span class="fc" id="L601">        final var length = v.length;</span>

<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        if (result.length != length) {</span>
<span class="nc" id="L604">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L607">        final var halfLength = length / 2;</span>
        double tmp;
<span class="fc bfc" id="L609" title="All 2 branches covered.">        for (int i = 0, j = length - 1; i &lt; halfLength; i++, j--) {</span>
<span class="fc" id="L610">            tmp = v[i];</span>
<span class="fc" id="L611">            result[i] = v[j];</span>
<span class="fc" id="L612">            result[j] = tmp;</span>
        }

<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (length % 2 != 0) {</span>
            // if length is odd, copy central value
<span class="fc" id="L617">            result[halfLength] = v[halfLength];</span>
        }
<span class="fc" id="L619">    }</span>

    /**
     * Reverses provided array. This method updates provided array to contain
     * its reversed values.
     *
     * @param v array to be reversed.
     */
    public static void reverse(final double[] v) {
<span class="fc" id="L628">        reverse(v, v);</span>
<span class="fc" id="L629">    }</span>

    /**
     * Returns a new array containing provided array having its elements in
     * reversed order.
     *
     * @param v array to be reversed.
     * @return a new instance containing reversed array.
     */
    public static double[] reverseAndReturnNew(final double[] v) {
<span class="fc" id="L639">        final var result = new double[v.length];</span>
<span class="fc" id="L640">        reverse(v, result);</span>
<span class="fc" id="L641">        return result;</span>
    }

    /**
     * Reverses the order of elements in the array.
     *
     * @param v      array to be reversed.
     * @param result instance where results will be stored.
     * @throws IllegalArgumentException if provided arrays don't have the same
     *                                  length.
     */
    public static void reverse(final Complex[] v, final Complex[] result) {

<span class="fc" id="L654">        final var length = v.length;</span>

<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (result.length != length) {</span>
<span class="nc" id="L657">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L660">        final var halfLength = length / 2;</span>
        Complex tmp;
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (v != result) {</span>
            // for different instances, copy values
<span class="fc bfc" id="L664" title="All 2 branches covered.">            for (int i = 0, j = length - 1; i &lt; halfLength; i++, j--) {</span>
<span class="fc" id="L665">                tmp = new Complex(v[i]);</span>
<span class="fc" id="L666">                result[i] = new Complex(v[j]);</span>
<span class="fc" id="L667">                result[j] = tmp;</span>
            }

<span class="fc bfc" id="L670" title="All 2 branches covered.">            if (length % 2 != 0) {</span>
                // if length is odd, copy central value
<span class="fc" id="L672">                result[halfLength] = new Complex(v[halfLength]);</span>
            }
        } else {
            // for same instances, rearrange values
<span class="fc bfc" id="L676" title="All 2 branches covered.">            for (int i = 0, j = length - 1; i &lt; halfLength; i++, j--) {</span>
<span class="fc" id="L677">                tmp = v[i];</span>
<span class="fc" id="L678">                result[i] = v[j];</span>
<span class="fc" id="L679">                result[j] = tmp;</span>
            }

<span class="fc bfc" id="L682" title="All 2 branches covered.">            if (length % 2 != 0) {</span>
                // if length is odd, copy central value
<span class="fc" id="L684">                result[halfLength] = v[halfLength];</span>
            }
        }
<span class="fc" id="L687">    }</span>

    /**
     * Reverses provided array. This method updates provided array to contain
     * its reversed values.
     *
     * @param v array to be reversed.
     */
    public static void reverse(final Complex[] v) {
<span class="fc" id="L696">        reverse(v, v);</span>
<span class="fc" id="L697">    }</span>

    /**
     * Returns a new array containing provided array having its elements in
     * reversed order.
     *
     * @param v array to be reversed.
     * @return a new instance containing reversed array.
     */
    public static Complex[] reverseAndReturnNew(final Complex[] v) {
<span class="fc" id="L707">        final var result = new Complex[v.length];</span>
<span class="fc" id="L708">        reverse(v, result);</span>
<span class="fc" id="L709">        return result;</span>
    }

    /**
     * Computes the squared root of each element of provided array and sets the
     * result into provided result array.
     *
     * @param v      input array to compute the squared root of each element.
     * @param result array where results will be stored.
     * @throws IllegalArgumentException if provided arrays don't have the same
     *                                  length.
     */
    public static void sqrt(final double[] v, final double[] result) {
<span class="fc" id="L722">        final var length = v.length;</span>

<span class="pc bpc" id="L724" title="1 of 2 branches missed.">        if (result.length != length) {</span>
<span class="nc" id="L725">            throw new IllegalArgumentException();</span>
        }

<span class="fc bfc" id="L728" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L729">            result[i] = Math.sqrt(v[i]);</span>
        }
<span class="fc" id="L731">    }</span>

    /**
     * Computes the squared root of each element of provided array and returns
     * the result as a new array.
     *
     * @param v input array to compute the squared root of each element.
     * @return a new array containing the squared root of each element of input
     * array.
     */
    public static double[] sqrtAndReturnNew(final double[] v) {
<span class="fc" id="L742">        final var result = new double[v.length];</span>
<span class="fc" id="L743">        sqrt(v, result);</span>
<span class="fc" id="L744">        return result;</span>
    }

    /**
     * Updates provided array by setting on each element its squared root.
     *
     * @param v input array to be updated with its squared root elements.
     */
    public static void sqrt(final double[] v) {
<span class="fc" id="L753">        sqrt(v, v);</span>
<span class="fc" id="L754">    }</span>

    /**
     * Finds the minimum value into provided array.
     *
     * @param v   array where minimum must be found.
     * @param pos position where minimum was found. Position will be stored at
     *            position zero of the array, if provided.
     * @return minimum value.
     */
    public static double min(final double[] v, final int[] pos) {
<span class="fc" id="L765">        final var length = v.length;</span>
<span class="fc" id="L766">        var min = Double.MAX_VALUE;</span>
<span class="fc" id="L767">        var foundPos = -1;</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">            if (v[i] &lt; min) {</span>
<span class="fc" id="L770">                min = v[i];</span>
<span class="fc" id="L771">                foundPos = i;</span>
            }
        }

<span class="pc bpc" id="L775" title="1 of 4 branches missed.">        if (pos != null &amp;&amp; pos.length &gt; 0) {</span>
<span class="fc" id="L776">            pos[0] = foundPos;</span>
        }

<span class="fc" id="L779">        return min;</span>
    }

    /**
     * Finds the minimum value into provided array.
     *
     * @param v array where minimum must be found.
     * @return minimum value.
     */
    public static double min(final double[] v) {
<span class="fc" id="L789">        return min(v, null);</span>
    }

    /**
     * Finds the maximum value into provided array.
     *
     * @param v   array where maximum must be found.
     * @param pos position where maximum was found. Position will be stored at
     *            position zero of the array, if provided.
     * @return maximum value.
     */
    public static double max(final double[] v, final int[] pos) {
<span class="fc" id="L801">        final var length = v.length;</span>
<span class="fc" id="L802">        var max = -Double.MAX_VALUE;</span>
<span class="fc" id="L803">        var foundPos = -1;</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">            if (v[i] &gt; max) {</span>
<span class="fc" id="L806">                max = v[i];</span>
<span class="fc" id="L807">                foundPos = i;</span>
            }
        }

<span class="pc bpc" id="L811" title="1 of 4 branches missed.">        if (pos != null &amp;&amp; pos.length &gt; 0) {</span>
<span class="fc" id="L812">            pos[0] = foundPos;</span>
        }

<span class="fc" id="L815">        return max;</span>
    }

    /**
     * Finds the maximum value into provided array.
     *
     * @param v array where maximum must be found.
     * @return maximum value.
     */
    public static double max(final double[] v) {
<span class="fc" id="L825">        return max(v, null);</span>
    }

    /**
     * Finds the minimum and maximum values into provided array and finds their
     * positions.
     *
     * @param v      array where minimum and maximum must be found.
     * @param result array of length 2 containing found minimum and maximum
     *               values at positions 0 and 1 respectively.
     * @param pos    array of length 2 containing positions where minimum and
     *               maximum where found in v array. Position 0 will contain minimum position,
     *               position 1 will contain maximum position.
     * @throws IllegalArgumentException if provided result or pos array don't
     *                                  have length 2.
     */
    public static void minMax(final double[] v, final double[] result, final int[] pos) {
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">        if (result.length != 2) {</span>
<span class="nc" id="L843">            throw new IllegalArgumentException(&quot;result must have length 2&quot;);</span>
        }
<span class="pc bpc" id="L845" title="2 of 4 branches missed.">        if (pos != null &amp;&amp; pos.length != 2) {</span>
<span class="nc" id="L846">            throw new IllegalArgumentException(&quot;pos must have length 2&quot;);</span>
        }

<span class="fc" id="L849">        final var length = v.length;</span>
<span class="fc" id="L850">        var min = Double.MAX_VALUE;</span>
<span class="fc" id="L851">        var max = -Double.MAX_VALUE;</span>
<span class="fc" id="L852">        var minPos = -1;</span>
<span class="fc" id="L853">        var maxPos = -1;</span>
<span class="fc bfc" id="L854" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc bfc" id="L855" title="All 2 branches covered.">            if (v[i] &lt; min) {</span>
<span class="fc" id="L856">                min = v[i];</span>
<span class="fc" id="L857">                minPos = i;</span>
            }
<span class="fc bfc" id="L859" title="All 2 branches covered.">            if (v[i] &gt; max) {</span>
<span class="fc" id="L860">                max = v[i];</span>
<span class="fc" id="L861">                maxPos = i;</span>
            }
        }

<span class="fc" id="L865">        result[0] = min;</span>
<span class="fc" id="L866">        result[1] = max;</span>
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">        if (pos != null) {</span>
<span class="fc" id="L868">            pos[0] = minPos;</span>
<span class="fc" id="L869">            pos[1] = maxPos;</span>
        }
<span class="fc" id="L871">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>