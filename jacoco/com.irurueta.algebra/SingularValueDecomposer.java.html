<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SingularValueDecomposer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-algebra</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.algebra</a> &gt; <span class="el_source">SingularValueDecomposer.java</span></div><h1>SingularValueDecomposer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.algebra;

/**
 * Computes Singular Value matrix decomposition, which consists
 * on factoring provided input matrix into three factors consisting of 2
 * unary matrices and 1 diagonal matrix containing singular values,
 * following next expression: A = U * S * V'.
 * Where A is provided input matrix of size m-by-n, U is an m-by-n unary
 * matrix, S is an n-by-n diagonal matrix containing singular values, and V'
 * denotes the transpose/conjugate of V and is an n-by-n unary matrix, for
 * m &amp;lt; n.
 */
@SuppressWarnings(&quot;DuplicatedCode&quot;)
public class SingularValueDecomposer extends Decomposer {

    /**
     * Constant defining default number of iterations to obtain convergence on
     * singular value estimation.
     */
    public static final int DEFAULT_MAX_ITERS = 30;

    /**
     * Constant defining minimum number of iterations allowed to obtain
     * convergence on singular value estimation.
     */
    public static final int MIN_ITERS = 1;

    /**
     * Constant defining minimum allowed value as threshold to determine
     * whether a singular value is negligible or not.
     */
    public static final double MIN_THRESH = 0.0;

    /**
     * Constant defining machine precision.
     */
    public static final double EPS = 1e-12;

    /**
     * Internal storage of U.
     */
    private Matrix u;

    /**
     * Internal storage of V.
     */
    private Matrix v;

    /**
     * Internal storage of singular values.
     */
    private double[] w;

    /**
     * Contains epsilon value, which indicates an estimation of numerical
     * precision given by this machine.
     */
    private final double eps;

    /**
     * Contains threshold used to determine whether a singular value can be
     * neglected or not due to numerical precision errors. This can be used to
     * determine effective rank of input matrix.
     */
    private double tsh;

    /**
     * Member containing maximum number of iterations to obtain convergence of
     * singular values estimation.
     * If singular values do not converge on provided maximum number of
     * iterations, then a NoConvergenceException will be thrown when calling
     * decompose() method.
     */
    private int maxIters;

    /**
     * Constructor of this class.
     */
    public SingularValueDecomposer() {
<span class="fc" id="L95">        super();</span>
<span class="fc" id="L96">        maxIters = DEFAULT_MAX_ITERS;</span>
<span class="fc" id="L97">        u = v = null;</span>
<span class="fc" id="L98">        w = null;</span>
<span class="fc" id="L99">        eps = EPS;</span>
<span class="fc" id="L100">    }</span>

    /**
     * Constructor of this class.
     *
     * @param maxIters Determines maximum number of iterations to be done when
     *                 decomposing input matrix into singular values so that singular values
     *                 converge properly.
     */
    public SingularValueDecomposer(final int maxIters) {
<span class="fc" id="L110">        super();</span>
<span class="fc" id="L111">        this.maxIters = maxIters;</span>
<span class="fc" id="L112">        u = v = null;</span>
<span class="fc" id="L113">        w = null;</span>
<span class="fc" id="L114">        eps = EPS;</span>
<span class="fc" id="L115">    }</span>

    /**
     * Constructor of this class.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     */
    public SingularValueDecomposer(final Matrix inputMatrix) {
<span class="fc" id="L123">        super(inputMatrix);</span>
<span class="fc" id="L124">        maxIters = DEFAULT_MAX_ITERS;</span>
<span class="fc" id="L125">        u = v = null;</span>
<span class="fc" id="L126">        w = null;</span>
<span class="fc" id="L127">        eps = EPS;</span>
<span class="fc" id="L128">    }</span>

    /**
     * Constructor of this class.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     * @param maxIters    Determines maximum number of iterations to be done when
     *                    decomposing input matrix into singular value so that singular values
     *                    converge properly.
     */
    public SingularValueDecomposer(final Matrix inputMatrix, final int maxIters) {
<span class="fc" id="L139">        super(inputMatrix);</span>
<span class="fc" id="L140">        this.maxIters = maxIters;</span>
<span class="fc" id="L141">        u = v = null;</span>
<span class="fc" id="L142">        w = null;</span>
<span class="fc" id="L143">        eps = EPS;</span>
<span class="fc" id="L144">    }</span>

    /**
     * Returns decomposer type corresponding to Singular Value decomposition.
     *
     * @return Decomposer type.
     */
    @Override
    public DecomposerType getDecomposerType() {
<span class="fc" id="L153">        return DecomposerType.SINGULAR_VALUE_DECOMPOSITION;</span>
    }

    /**
     * Sets reference to input matrix to be decomposed.
     *
     * @param inputMatrix Reference to input matrix to be decomposed.
     * @throws LockedException Exception thrown if attempting to call this
     *                         method while this instance remains locked.
     */
    @Override
    public void setInputMatrix(final Matrix inputMatrix) throws LockedException {
<span class="fc" id="L165">        super.setInputMatrix(inputMatrix);</span>
<span class="fc" id="L166">        u = v = null;</span>
<span class="fc" id="L167">        w = null;</span>
<span class="fc" id="L168">    }</span>

    /**
     * Returns boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     * Attempting to retrieve decomposition results when not available, will
     * probably raise a NotAvailableException
     *
     * @return Boolean indicating whether decomposition has been computed and
     * results can be retrieved.
     */
    @Override
    public boolean isDecompositionAvailable() {
<span class="pc bpc" id="L181" title="2 of 6 branches missed.">        return u != null || v != null || w != null;</span>
    }

    /**
     * This method computes Singular Value matrix decomposition, which consists
     * on factoring provided input matrix into three factors consisting of 2
     * unary matrices and 1 diagonal matrix containing singular values,
     * following next expression: A = U * S * V'.
     * Where A is provided input matrix of size m-by-n, U is an m-by-n unary
     * matrix, S is an n-by-n diagonal matrix containing singular values, and V'
     * denotes the transpose/conjugate of V and is an n-by-n unary matrix, for
     * m &amp;lt; n.
     * Note: Factors U, S and V will be accessible once Singular Value
     * decomposition has been computed.
     * Note: During execution of this method, Singular Value decomposition will
     * be available and operations such as retrieving matrix factors, or
     * computing rank of matrices among others will be able to be done.
     * Attempting to call any of such operations before calling this method will
     * raise a NotAvailableException because they require computation of
     * SingularValue decomposition first.
     *
     * @throws NotReadyException   Exception thrown if attempting to call this
     *                             method when this instance is not ready (i.e. no input matrix has been
     *                             provided).
     * @throws LockedException     Exception thrown if this decomposer is already
     *                             locked before calling this method. Notice that this method will actually
     *                             lock this instance while it is being executed.
     * @throws DecomposerException Exception thrown if for any reason
     *                             decomposition fails while being executed, like when convergence of
     *                             results cannot be obtained, etc.
     */
    @Override
    public void decompose() throws NotReadyException, LockedException, DecomposerException {

<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (!isReady()) {</span>
<span class="fc" id="L216">            throw new NotReadyException();</span>
        }
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L219">            throw new LockedException();</span>
        }

<span class="fc" id="L222">        locked = true;</span>

<span class="fc" id="L224">        final var m = inputMatrix.getRows();</span>
<span class="fc" id="L225">        final var n = inputMatrix.getColumns();</span>

        // copy input matrix into U
<span class="fc" id="L228">        u = new Matrix(inputMatrix);</span>
<span class="fc" id="L229">        w = new double[n];</span>
        try {
<span class="fc" id="L231">            v = new Matrix(n, n);</span>
<span class="nc" id="L232">        } catch (final WrongSizeException ignore) {</span>
            // never happens
<span class="fc" id="L234">        }</span>
        try {
<span class="fc" id="L236">            internalDecompose();</span>
<span class="fc" id="L237">            reorder();</span>
<span class="fc" id="L238">            setNegligibleSingularValueThreshold(0.5 * Math.sqrt(m + n + 1.0) * w[0] * eps);</span>
<span class="fc" id="L239">            locked = false;</span>
<span class="nc" id="L240">        } catch (final DecomposerException e) {</span>
<span class="nc" id="L241">            u = v = null;</span>
<span class="nc" id="L242">            w = null;</span>
<span class="nc" id="L243">            locked = false;</span>
<span class="nc" id="L244">            throw e;</span>
<span class="fc" id="L245">        }</span>
<span class="fc" id="L246">    }</span>

    /**
     * Returns maximum number of iterations to be done in order to obtain
     * convergence of singular values when computing input matrix Singular
     * Value Decomposition.
     *
     * @return Maximum number of iterations to obtain singular values
     * convergence.
     */
    public int getMaxIterations() {
<span class="fc" id="L257">        return maxIters;</span>
    }

    /**
     * SSets maximum number of iterations to be done in order to obtain
     * convergence of singular values when computing input matrix Singular
     * Value Decomposition.
     * Note: This parameter should rarely be modified because default value
     * is usually good enough.
     * Note: If convergence of singular values is not achieved within provided
     * maximum number of iterations, a DecomposerException will be thrown when
     * calling decompose();
     *
     * @param maxIters Maximum number of iterations to obtain convergence of
     *                 singular values. Provided value must be 1 or greater, otherwise an
     *                 IllegalArgumentException will be thrown.
     * @throws LockedException          Exception thrown if attempting to call this
     *                                  method while this instance remains locked.
     * @throws IllegalArgumentException Exception thrown if provided value
     *                                  for maxIters is out of valid range of values.
     */
    public void setMaxIterations(final int maxIters) throws LockedException {
<span class="pc bpc" id="L279" title="1 of 2 branches missed.">        if (isLocked()) {</span>
<span class="nc" id="L280">            throw new LockedException();</span>
        }
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (maxIters &lt; MIN_ITERS) {</span>
<span class="fc" id="L283">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L286">        this.maxIters = maxIters;</span>
<span class="fc" id="L287">    }</span>

    /**
     * Returns threshold to be used for determining whether a singular value is
     * negligible or not.
     * This threshold can be used to consider a singular value as zero or not,
     * since small singular values might appear in places where they should be
     * zero because of rounding errors and machine precision.
     * Singular values considered as zero determine aspects such as rank,
     * nullability, null-space or range space.
     *
     * @return Threshold to be used for determining whether a singular value
     * is negligible or not.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition.
     *                               To avoid this exception call decompose() method first.
     */
    public double getNegligibleSingularValueThreshold() throws NotAvailableException {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (!isDecompositionAvailable()) {</span>
<span class="fc" id="L306">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L308">        return tsh;</span>
    }

    /**
     * Returns a new matrix instance containing the left singular vector (U
     * factor) from Singular Value matrix decomposition, which consists
     * on decomposing a matrix using the following expression:
     * A = U * S * V'.
     * Where A is provided input matrix of size m-by-n and U is an m-by-n
     * unary matrix for m &amp;lt; n.
     *
     * @return Matrix instance containing the left singular vectors from a
     * Singular Value decomposition.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition. To avoid
     *                               this exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getU() throws NotAvailableException {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L328">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L330">        return u;</span>
    }

    /**
     * Returns a new matrix instance containing the right singular vectors
     * (V factor) from Singular Value matrix decomposition, which consists on
     * decomposing a matrix using the following expression:
     * A = U * S * V',
     * Where A is provided input matrix of size m-by-n and V' denotes the
     * transpose/conjugate of V, which is an n-by-n unary matrix for m &amp;lt; n.
     *
     * @return Matrix instance containing the right singular vectors from a
     * Singular Value decomposition.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition. To avoid
     *                               this exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getV() throws NotAvailableException {
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L350">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L352">        return v;</span>
    }

    /**
     * Returns a new vector instance containing all singular values after
     * decomposition.
     * Returned vector is equal to the diagonal of S matrix within expression:
     * A = U * S * V' where A is provided input matrix and S is a diagonal
     * matrix containing singular values on its diagonal.
     *
     * @return singular values.
     * @throws NotAvailableException if decomposition has not yet been computed.
     */
    public double[] getSingularValues() throws NotAvailableException {
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L367">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L369">        return w;</span>
    }

    /**
     * Copies diagonal matrix into provided instance containing all singular
     * values on its diagonal after Singular Value matrix decomposition, which
     * consists on decomposing a matrix using the following expression:
     * A = U * S * V'.
     * Where A is provided input matrix of size m-by-n and S is a diagonal
     * matrix of size n-by-n for m &amp;lt; n.
     *
     * @param m matrix instance containing all singular values on its
     *          diagonal after execution of this method.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition. To avoid
     *                               this exception call decompose() method first.
     * @throws WrongSizeException    if provided matrix does not have size n-by-n.
     * @see #decompose()
     */
    public void getW(final Matrix m) throws NotAvailableException, WrongSizeException {
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L390">            throw new NotAvailableException();</span>
        }
<span class="fc bfc" id="L392" title="All 4 branches covered.">        if (m.getRows() != w.length || m.getColumns() != w.length) {</span>
<span class="fc" id="L393">            throw new WrongSizeException();</span>
        }
<span class="fc" id="L395">        Matrix.diagonal(w, m);</span>
<span class="fc" id="L396">    }</span>

    /**
     * Returns a new diagonal matrix instance containing all singular values on
     * its diagonal after Singular Value matrix decomposition, which consists
     * on decomposing a matrix using the following expression: A = U * S * V'.
     * Where A is provided input matrix of size m-by-n and S is a diagonal
     * matrix of size n-by-n for m &amp;lt; n.
     *
     * @return Returned matrix instance containing all singular values on its
     * diagonal.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition. To avoid
     *                               this exception call decompose() method first.
     * @see #decompose()
     */
    public Matrix getW() throws NotAvailableException {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L414">            throw new NotAvailableException();</span>
        }

        // copy S array into a new diagonal matrix
<span class="fc" id="L418">        return Matrix.diagonal(w);</span>
    }

    /**
     * Returns the 2-norm of provided input matrix, which is equal to the highest
     * singular value found after decomposition. This is also called the Ky Fan
     * 1-norm.
     * This norm is also equal to the square root of Frobenius norm of the
     * squared provided input matrix. In other words:
     * sqrt(norm(A' * A, 'fro')) in Matlab notation.
     * Where A is provided input matrix and A' is its transpose, and hence
     * A' * A can be considered the squared matrix of A, and Frobenius norm
     * is defined as the square root of the sum of the squared elements of a
     * matrix: sqr(sum(A(:).^2))
     *
     * @return The 2-norm of provided input matrix, which is equal to the
     * highest singular value.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public double getNorm2() throws NotAvailableException {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L442">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L444">        return w[0];</span>
    }

    /**
     * Returns the condition number of provided input matrix found after
     * decomposition.
     * The condition number of a matrix measures the sensitivity of the
     * solution of a system of linear equations to errors in the data.
     * It gives an indication of the accuracy of the results from matrix
     * inversion and the solution of a linear system of equations.
     * A problem with a low condition number is said to be well-conditioned,
     * whereas a problem with a high condition number is said to be
     * ill-conditioned.
     * The condition number is a property of a matrix and is not related to the
     * algorithm or floating point accuracy of a machine to solve a linear
     * system of equations or make matrix inversion.
     * When solving a linear system of equations (A * X = b), one should think
     * of the condition number as being (very roughly) the rate at which the
     * solution x will change with respect to a change in b.
     * Thus, if the condition number is large, even a small error in b may
     * cause a large error in x. On the other hand, if the condition number is
     * small then the error in x will not be much bigger than the error in b.
     * One way to find the condition number is by using the ration of the
     * maximal and minimal singular values of a matrix, which is what this
     * method returns.
     *
     * @return The condition number of provided input matrix.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public double getConditionNumber() throws NotAvailableException {
<span class="fc" id="L477">        return 1.0 / getReciprocalConditionNumber();</span>
    }

    /**
     * Returns the inverse of the condition number, i.e. 1.0 / condition number.
     * Hence, when reciprocal condition number is close to zero, input matrix
     * will be ill-conditioned.
     * For more information see getConditionNumber()
     *
     * @return Inverse of the condition number.
     * @throws NotAvailableException Exception thrown if attempting to call
     *                               this method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     * @see #getConditionNumber()
     */
    public double getReciprocalConditionNumber() throws NotAvailableException {
<span class="pc bpc" id="L494" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L495">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L498">        final var columns = inputMatrix.getColumns();</span>
<span class="pc bpc" id="L499" title="2 of 4 branches missed.">        return (w[0] &lt;= 0.0 || w[columns - 1] &lt;= 0.0) ? 0.0 : w[columns - 1] / w[0];</span>
    }

    /**
     * Returns effective numerical matrix rank.
     * By definition rank of a matrix can be found as the number of non-zero
     * singular values of such matrix found after decomposition.
     * However, rounding error and machine precision may lead to small but non-zero
     * singular values in a rank deficient matrix.
     * This method tries to cope with such rounding errors by taking into
     * account only those non-negligible singular values to determine input
     * matrix rank.
     * The Rank-nullity theorem states that for a matrix A of size m-by-n then:
     * rank(A) + nullity(A) = n
     * Where A is input matrix and n is the number of columns of such matrix.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Effective numerical matrix rank.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  value close to zero.
     * @see #decompose()
     */
    public int getRank(final double singularValueThreshold) throws NotAvailableException {
<span class="pc bpc" id="L528" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L529">            throw new NotAvailableException();</span>
        }
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (singularValueThreshold &lt; MIN_THRESH) {</span>
<span class="nc" id="L532">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L535">        var r = 0;</span>
<span class="fc bfc" id="L536" title="All 2 branches covered.">        for (var aW : w) {</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">            if (aW &gt; singularValueThreshold) {</span>
<span class="fc" id="L538">                r++;</span>
            }
        }
<span class="fc" id="L541">        return r;</span>
    }

    /**
     * Returns effective numerical matrix rank.
     * By definition rank of a matrix can be found as the number of non-zero
     * singular values of such matrix found after decomposition.
     * However, rounding error and machine precision may lead to small but non-zero
     * singular values in a rank deficient matrix.
     * This method tries to cope with such rounding error by taking into account
     * only those non-negligible singular values to determine input matrix rank.
     * The Rank-nullity theorem states that for a matrix A of size m-by-n then:
     * rank(A) + nullity(A) = n
     * Where A is input matrix and n is number of columns of such matrix.
     * Note: This method makes same actions as int getRank(double)
     * except that singular value threshold is automatically computed by taking
     * into account input matrix size, maximal singular value and machine
     * precision. This threshold is good enough for most situations, and hence
     * we discourage setting it manually.
     *
     * @return Effective numerical matrix rank.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public int getRank() throws NotAvailableException {
<span class="fc" id="L568">        return getRank(getNegligibleSingularValueThreshold());</span>
    }

    /**
     * Returns effective numerical matrix nullity.
     * By definition nullity of a matrix can be found as the number of zero or
     * negligible singular values of provided input matrix after decomposition.
     * Rounding error and machine precision may lead to small but non-zero
     * singular values in a rank deficient matrix.
     * This method tries to cope with such rounding error by taking into account
     * only those negligible singular values to determine input matrix nullity.
     * The Rank-nullity theorem states that for a matrix A of size m-by-n then:
     * rank(A) + nullity(A) = n
     * Where A is input matrix and n is number of columns of such matrix.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Effective numerical matrix nullity.
     * @throws NotAvailableException    Exception thrown if attempting to call
     *                                  this method before computing Singular Value decomposition.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  value close to zero.
     * @see #decompose()
     */
    public int getNullity(final double singularValueThreshold) throws NotAvailableException {
<span class="fc" id="L595">        final var n = inputMatrix.getColumns();</span>
<span class="fc" id="L596">        return n - getRank(singularValueThreshold);</span>
    }

    /**
     * Returns effective numerical matrix nullity.
     * By definition nullity of a matrix can be found as the number of zero or
     * negligible singular values of provided input matrix after decomposition.
     * Rounding error and machine precision may lead to small but non-zero
     * singular values in a rank deficient matrix.
     * This method tries to cope with such rounding error by taking into account
     * only those negligible singular values to determine input matrix nullity.
     * The Rank-nullity theorem states that for a matrix A of size m-by-n then:
     * rank(A) + nullity(A) = n
     * Where A is input matrix and n is number of columns of such matrix.
     * Note: This method makes the same actions as int getNullity(double) except
     * that singular value threshold is automatically computed by taking into
     * account input matrix size, maximal singular value and machine precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     *
     * @return Effective numerical matrix nullity.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @see #decompose()
     */
    public int getNullity() throws NotAvailableException {
<span class="fc" id="L623">        return getNullity(getNegligibleSingularValueThreshold());</span>
    }

    /**
     * Sets into provided range matrix the Range space of provided input matrix,
     * which spans a subspace of dimension equal to the rank of input matrix.
     * Range space is equal to the columns of U corresponding to non-negligible
     * singular values.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @param range                  Matrix containing Range space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has rank
     *                                  zero or also if attempting to call this method before computing Singular
     *                                  Value decomposition. To avoid this exception call decompose() method
     *                                  first and make sure that input matrix has non-zero rank.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public void getRange(final double singularValueThreshold, final Matrix range) throws NotAvailableException {
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L646">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L648">        final var rank = getRank(singularValueThreshold);</span>
<span class="fc" id="L649">        internalGetRange(rank, singularValueThreshold, range);</span>
<span class="fc" id="L650">    }</span>

    /**
     * Sets into provided range matrix the Range space of provided input matrix,
     * which spans a subspace of dimension equal to the rank of input matrix.
     * Range space is equal to the columns of U corresponding to non-negligible
     * singular values.
     * This method performs same actions as getRange(double, Matrix) except that
     * singular value threshold is automatically computed by taking into account
     * input matrix size, maximal singular value and machine precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     *
     * @param range Matrix containing Range space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has rank
     *                                  zero or also if attempting to call this method before computing Singular
     *                                  Value decomposition. To avoid this exception call decompose() method
     *                                  first and make sure that input matrix has non-zero rank.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public void getRange(final Matrix range) throws NotAvailableException {
<span class="fc" id="L674">        getRange(getNegligibleSingularValueThreshold(), range);</span>
<span class="fc" id="L675">    }</span>

    /**
     * Returns matrix containing Range space of provided input matrix, which
     * spans a subspace of dimension equal to the rank of input matrix.
     * Range space is equal to the columns of U corresponding to non-negligible
     * singular values.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Matrix containing Range space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has rank
     *                                  zero or also if attempting to call this method before computing Singular
     *                                  Value decomposition. To avoid this exception call decompose() method
     *                                  first and make sure that input matrix has non-zero rank.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public Matrix getRange(final double singularValueThreshold) throws NotAvailableException {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L697">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L699">        final var rows = inputMatrix.getRows();</span>
<span class="fc" id="L700">        final var rank = getRank(singularValueThreshold);</span>

        Matrix out;
        try {
<span class="fc" id="L704">            out = new Matrix(rows, rank);</span>
<span class="nc" id="L705">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L706">            throw new NotAvailableException(e);</span>
<span class="fc" id="L707">        }</span>
<span class="fc" id="L708">        internalGetRange(rank, singularValueThreshold, out);</span>
<span class="fc" id="L709">        return out;</span>
    }

    /**
     * Return matrix containing Range space of provided input matrix, which
     * spans a subspace of dimension equal to the rank of input matrix.
     * Range space is equal to the columns of U corresponding to non-negligible
     * singular values.
     * This method performs same actions as Matrix getRange(double) except that
     * singular value threshold is automatically computed by taking into account
     * input matrix size, maximal singular value and machine precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     *
     * @return Matrix containing Range space of provided input matrix
     * @throws NotAvailableException Exception thrown if input matrix has rank
     *                               zero or also if attempting to call this method before computing Singular
     *                               Value decomposition. To avoid this exception call decompose() method
     *                               first and make sure that input matrix has non-zero rank.
     */
    public Matrix getRange() throws NotAvailableException {
<span class="fc" id="L730">        return getRange(getNegligibleSingularValueThreshold());</span>
    }

    /**
     * Sets into provided matrix null-space of provided input matrix, which spans
     * a subspace of dimension equal to the nullity of input matrix. Null-space
     * is equal to the columns of V corresponding to negligible singular values.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @param nullspace              Matrix containing null-space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has full
     *                                  rank, and hence its nullity is zero, or also if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first and make sure that input matrix
     *                                  is rank deficient.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public void getNullspace(final double singularValueThreshold, final Matrix nullspace)
            throws NotAvailableException {
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L754">            throw new NotAvailableException();</span>
        }
<span class="fc" id="L756">        final var nullity = getNullity(singularValueThreshold);</span>
<span class="fc" id="L757">        internalGetNullspace(nullity, singularValueThreshold, nullspace);</span>
<span class="fc" id="L758">    }</span>

    /**
     * Sets into provided matrix null-space of provided input matrix, which spans
     * a subspace of dimension equal to the nullity of input matrix. Null-space
     * is equal to the columns of V corresponding to negligible singular values.
     * This method performs same actions as getNullspace(double, Matrix) except
     * that singular value threshold is automatically computed by taking into
     * account input matrix size, maximal singular value and machine precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     *
     * @param nullspace Matrix containing null-space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has full
     *                                  rank, and hence its nullity is zero, or also if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first and make sure that input matrix
     *                                  is rank deficient.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public void getNullspace(final Matrix nullspace) throws NotAvailableException {
<span class="fc" id="L782">        getNullspace(getNegligibleSingularValueThreshold(), nullspace);</span>
<span class="fc" id="L783">    }</span>

    /**
     * Returns matrix containing null-space of provided input matrix, which spans
     * a subspace of dimension equal to the nullity of input matrix. Null-space
     * is equal to the columns of V corresponding to negligible singular values.
     *
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Matrix containing null-space of provided input matrix.
     * @throws NotAvailableException    Exception thrown if input matrix has full
     *                                  rank, and hence its nullity is zero, or also if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first and make sure that input matrix
     *                                  is rank deficient.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is negative. Returned singular values after decomposition
     *                                  are always positive, and hence, provided threshold should be a positive
     *                                  near to zero value.
     */
    public Matrix getNullspace(final double singularValueThreshold) throws NotAvailableException {
<span class="pc bpc" id="L804" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L805">            throw new NotAvailableException();</span>
        }

<span class="fc" id="L808">        final var columns = inputMatrix.getColumns();</span>
<span class="fc" id="L809">        final var nullity = getNullity(singularValueThreshold);</span>
        Matrix out;
        try {
<span class="fc" id="L812">            out = new Matrix(columns, nullity);</span>
<span class="nc" id="L813">        } catch (final WrongSizeException e) {</span>
<span class="nc" id="L814">            throw new NotAvailableException(e);</span>
<span class="fc" id="L815">        }</span>
<span class="fc" id="L816">        internalGetNullspace(nullity, singularValueThreshold, out);</span>
<span class="fc" id="L817">        return out;</span>
    }

    /**
     * Returns matrix containing null-space of provided input matrix, which
     * spans a subspace of dimension equal to the nullity of input matrix.
     * Null-space is equal to the columns of V corresponding to negligible
     * singular values.
     *
     * @return Matrix containing null-space of provided input matrix.
     * This method performs same actions as Matrix {@link #getNullspace(double)} except
     * that singular value threshold is automatically computed by taking into
     * account input matrix size, maximal singular value and machine precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     * @throws NotAvailableException Exception thrown if input matrix has full
     *                               rank, and hence its nullity is zero, or also if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first and make sure that input matrix
     *                               is rank deficient.
     */
    public Matrix getNullspace() throws NotAvailableException {
<span class="fc" id="L839">        return getNullspace(getNegligibleSingularValueThreshold());</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A is the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameters
     * matrix.
     * Note: This method can be reused for different b matrices without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise a WrongSizeException will be raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     * Note: Provided result matrix will be resized if needed
     *
     * @param b                      Parameters matrix that determine a linear system of equations.
     *                               Provided matrix must have the same number of rows as provided input
     *                               matrix for Singular Value decomposition. Besides, each column on
     *                               parameters matrix will represent a new system of equations, whose
     *                               solution will be returned on appropriate column as an output of this
     *                               method.
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @param result                 Matrix containing least squares solution of linear system
     *                               of equations on each column for each column of provided parameters matrix
     *                               b.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first.
     * @throws WrongSizeException       Exception thrown if provided parameters matrix
     *                                  (b) does not have the same number of rows as input matrix being Singular
     *                                  Value decomposed.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is lower than minimum allowed value (MIN_THRESH).
     * @see #decompose()
     */
    public void solve(final Matrix b, final double singularValueThreshold, final Matrix result)
            throws NotAvailableException, WrongSizeException {
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L881">            throw new NotAvailableException();</span>
        }

<span class="fc bfc" id="L884" title="All 2 branches covered.">        if (b.getRows() != inputMatrix.getRows()) {</span>
<span class="fc" id="L885">            throw new WrongSizeException();</span>
        }

<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (singularValueThreshold &lt; MIN_THRESH) {</span>
<span class="fc" id="L889">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L892">        final var m = inputMatrix.getRows();</span>
<span class="fc" id="L893">        final var n = inputMatrix.getColumns();</span>
<span class="fc" id="L894">        final var p = b.getColumns();</span>

<span class="fc" id="L896">        final var bcol = new double[m];</span>
        double[] xx;

        // resize result matrix if needed
<span class="pc bpc" id="L900" title="1 of 4 branches missed.">        if (result.getRows() != n || result.getColumns() != p) {</span>
<span class="fc" id="L901">            result.resize(n, p);</span>
        }

<span class="fc bfc" id="L904" title="All 2 branches covered.">        for (var j = 0; j &lt; p; j++) {</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">            for (var i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L906">                bcol[i] = b.getElementAt(i, j);</span>
            }

<span class="fc" id="L909">            xx = solve(bcol, singularValueThreshold);</span>
            // set column j of X using values in vector xx
<span class="fc" id="L911">            result.setSubmatrix(0, j, n - 1, j, xx);</span>
        }
<span class="fc" id="L913">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A is the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameter
     * matrix.
     * Note: This method can be reused for different b matrices without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise a WrongSizeException will be raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     * Note: This method performs same actions as Matrix solve(Matrix, double)
     * except that singular value threshold is automatically computed by taking
     * into account input matrix size, maximal singular value and machine
     * precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     * Note: Provided result matrix will be resized if needed
     *
     * @param b      Parameters matrix that determines a linear system of equations.
     *               Provided matrix must have the same number of rows as provided input
     *               matrix for Singular Value decomposition. Besides, each column on
     *               parameters matrix will represent a new system of equations, whose
     *               solution will be returned on appropriate column as an output of this method.
     * @param result Matrix containing least squares solution of linear system
     *               of equations on each column for each column of provided parameters matrix
     *               b.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @throws WrongSizeException    Exception thrown if provided parameters matrix
     *                               (b) does not have the same number of rows as input matrix being Singular
     *                               Value decomposed.
     * @see #decompose()
     */
    public void solve(final Matrix b, final Matrix result) throws NotAvailableException, WrongSizeException {
<span class="fc" id="L953">        solve(b, getNegligibleSingularValueThreshold(), result);</span>
<span class="fc" id="L954">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A is the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameter
     * matrix.
     * Note: This method can be reused for different b matrices without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise a WrongSizeException will be raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     *
     * @param b                      Parameters matrix that determine a linear system of equations.
     *                               Provided matrix must have the same number of rows as provided input
     *                               matrix for Singular Value decomposition. Besides, each column on
     *                               parameters matrix will represent a new system of equations, whose
     *                               solution will be returned on appropriate column as an output of this
     *                               method.
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Matrix containing least squares solution of linear system of
     * equations on each column for each column of provided parameters matrix b.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing Singular Value decomposition. To avoid this
     *                                  exception call decompose() method first.
     * @throws WrongSizeException       Exception thrown if provided parameters matrix
     *                                  (b) does not have the same number of rows as input matrix being Singular
     *                                  Value decomposed.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is lower than minimum allowed value (MIN_THRESH).
     * @see #decompose()
     */
    public Matrix solve(final Matrix b, final double singularValueThreshold)
            throws NotAvailableException, WrongSizeException {
<span class="fc" id="L992">        final var n = inputMatrix.getColumns();</span>
<span class="fc" id="L993">        final var p = b.getColumns();</span>
<span class="fc" id="L994">        final var x = new Matrix(n, p);</span>
<span class="fc" id="L995">        solve(b, singularValueThreshold, x);</span>
<span class="fc" id="L996">        return x;</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A is the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameter
     * matrix.
     * Note: This method can be reused for different b matrices without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b matrix must have the same number of rows as provided
     * input matrix A, otherwise a WrongSizeException will be raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     * Note: This method performs same actions as Matrix solve(Matrix, double)
     * except that singular value threshold is automatically computed by taking
     * into account input matrix size, maximal singular value and machine
     * precision.
     * This threshold is good enough for most situations, and hence we
     * discourage setting it manually.
     *
     * @param b Parameters matrix that determines a linear system of equations.
     *          Provided matrix must have the same number of rows as provided input
     *          matrix for Singular Value decomposition. Besides, each column on
     *          parameters matrix will represent a new system of equations, whose
     *          solution will be returned on appropriate column as an output of this method.
     * @return Matrix containing least squares solution of linear system of
     * equations on each column for each column of provided parameters matrix b.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing Singular Value decomposition. To avoid this
     *                               exception call decompose() method first.
     * @throws WrongSizeException    Exception thrown if provided parameters matrix
     *                               (b) does not have the same number of rows as input matrix being Singular
     *                               Value decomposed.
     * @see #decompose()
     */
    public Matrix solve(final Matrix b) throws NotAvailableException,
            WrongSizeException {
<span class="fc" id="L1036">        return solve(b, getNegligibleSingularValueThreshold());</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A i s the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameters
     * array.
     * Note: This method can be reused for different b arrays without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b array must have the same length as the number of rows
     * on provided input matrix A, otherwise a WrongSizeException will be
     * raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     *
     * @param b                      Parameters array that determines a linear system of equations.
     *                               Provided array must have the same length as number of rows on provided
     *                               input matrix for Singular Value decomposition.
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @param result                 Vector where least squares solution of linear system of
     *                               equations for provided parameters array b will be stored.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing SingularValue decomposition.
     *                                  To avoid this exception call decompose() method first.
     * @throws WrongSizeException       Exception thrown if provided parameters array
     *                                  (b) does not have the same length as number of rows on input matrix being
     *                                  Singular Value decomposed or if provided result array does not have the
     *                                  same length as the number of columns on input matrix.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is lower than minimum allowed value (MIN_THRESH).
     * @see #decompose()
     */
    public void solve(final double[] b, final double singularValueThreshold,
                      final double[] result) throws NotAvailableException, WrongSizeException {
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">        if (!isDecompositionAvailable()) {</span>
<span class="nc" id="L1075">            throw new NotAvailableException();</span>
        }

<span class="fc bfc" id="L1078" title="All 2 branches covered.">        if (b.length != inputMatrix.getRows()) {</span>
<span class="fc" id="L1079">            throw new WrongSizeException();</span>
        }

<span class="fc bfc" id="L1082" title="All 2 branches covered.">        if (singularValueThreshold &lt; MIN_THRESH) {</span>
<span class="fc" id="L1083">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L1086">        final var m = inputMatrix.getRows();</span>
<span class="fc" id="L1087">        final var n = inputMatrix.getColumns();</span>

<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">        if (result.length != n) {</span>
<span class="nc" id="L1090">            throw new WrongSizeException();</span>
        }

        double s;
<span class="fc" id="L1094">        final var tmp = new double[n];</span>

<span class="fc bfc" id="L1096" title="All 2 branches covered.">        for (var j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1097">            s = 0.0;</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">            if (w[j] &gt; singularValueThreshold) {</span>
<span class="fc bfc" id="L1099" title="All 2 branches covered.">                for (var i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L1100">                    s += u.getElementAt(i, j) * b[i];</span>
                }
<span class="fc" id="L1102">                s /= w[j];</span>
            }
<span class="fc" id="L1104">            tmp[j] = s;</span>
        }
<span class="fc bfc" id="L1106" title="All 2 branches covered.">        for (var j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1107">            s = 0.0;</span>
<span class="fc bfc" id="L1108" title="All 2 branches covered.">            for (var jj = 0; jj &lt; n; jj++) {</span>
<span class="fc" id="L1109">                s += v.getElementAt(j, jj) * tmp[jj];</span>
            }
<span class="fc" id="L1111">            result[j] = s;</span>
        }
<span class="fc" id="L1113">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A i s the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameters
     * array.
     * Note: This method can be reused for different b arrays without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b array must have the same length as the number of rows
     * on provided input matrix A, otherwise a WrongSizeException will be
     * raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     * Note: this method performs same actions as double[] solve(double[],
     * double) except that singular value threshold is automatically computed by
     * taking into account input matrix size, maximal singular value and machine
     * precision.
     * This threshold is good enough for most situations, and hence we discourage
     * setting it manually.
     *
     * @param b      Parameters array that determines a linear system of equations.
     *               Provided array must have the same length as number of rows on provided
     *               input matrix for Singular Value decomposition.
     * @param result Vector where least squares solution of linear system of
     *               equations for provided parameters array b will be stored.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing SingularValue decomposition.
     *                                  To avoid this exception call decompose() method first.
     * @throws WrongSizeException       Exception thrown if provided parameters array
     *                                  (b) does not have the same length as number of rows on input matrix being
     *                                  Singular Value decomposed or if provided result array does not have the
     *                                  same length as the number of columns on input matrix.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is lower than minimum allowed value (MIN_THRESH).
     * @see #decompose()
     */
    public void solve(final double[] b, final double[] result) throws NotAvailableException, WrongSizeException {
<span class="fc" id="L1153">        solve(b, getNegligibleSingularValueThreshold(), result);</span>
<span class="fc" id="L1154">    }</span>

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A i s the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameters
     * array.
     * Note: This method can be reused for different b arrays without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b array must have the same length as the number of rows
     * on provided input matrix A, otherwise a WrongSizeException will be
     * raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     *
     * @param b                      Parameters array that determines a linear system of equations.
     *                               Provided array must have the same length as number of rows on provided
     *                               input matrix for Singular Value decomposition.
     * @param singularValueThreshold Threshold used to determine whether a
     *                               singular value is negligible or not.
     * @return Vector containing least squares solution of linear system of
     * equations for provided parameters array b.
     * @throws NotAvailableException    Exception thrown if attempting to call this
     *                                  method before computing SingularValue decomposition.
     *                                  To avoid this exception call decompose() method first.
     * @throws WrongSizeException       Exception thrown if provided parameters array
     *                                  (b) does not have the same length as number of rows on input matrix being
     *                                  Singular Value decomposed.
     * @throws IllegalArgumentException Exception thrown if provided singular
     *                                  value threshold is lower than minimum allowed value (MIN_THRESH).
     * @see #decompose()
     */
    public double[] solve(final double[] b, final double singularValueThreshold) throws NotAvailableException,
            WrongSizeException {
<span class="fc" id="L1190">        final var n = inputMatrix.getColumns();</span>

<span class="fc" id="L1192">        final var x = new double[n];</span>
<span class="fc" id="L1193">        solve(b, singularValueThreshold, x);</span>
<span class="fc" id="L1194">        return x;</span>
    }

    /**
     * Solves a linear system of equations of the following form: A * X = B
     * using the pseudo-inverse to find the least squares solution.
     * Where A i s the input matrix provided for Singular Value decomposition,
     * X is the solution to the system of equations, and B is the parameters
     * array.
     * Note: This method can be reused for different b arrays without having
     * to recompute Singular Value decomposition on the same input matrix.
     * Note: Provided b array must have the same length as the number of rows
     * on provided input matrix A, otherwise a WrongSizeException will be
     * raised.
     * Note: In order to execute this method, a Singular Value decomposition
     * must be available, otherwise a NotAvailableException will be raised. In
     * order to avoid this exception call decompose() method first.
     * Note: this method performs same actions as double[] solve(double[],
     * double) except that singular value threshold is automatically computed by
     * taking into account input matrix size, maximal singular value and machine
     * precision.
     * This threshold is good enough for most situations, and hence we discourage
     * setting it manually.
     *
     * @param b Parameters array that determines a linear system of equations.
     *          Provided array must have the same length as number of rows on provided
     *          input matrix for Singular Value decomposition.
     * @return Vector containing least squares solution of linear system of
     * equations for provided parameters array b.
     * @throws NotAvailableException Exception thrown if attempting to call this
     *                               method before computing SingularValue decomposition.
     *                               To avoid this exception call decompose() method first.
     * @throws WrongSizeException    Exception thrown if provided parameters array
     *                               (b) does not have the same length as number of rows on input matrix being
     *                               Singular Value decomposed.
     * @see #decompose()
     */
    public double[] solve(final double[] b) throws NotAvailableException, WrongSizeException {
<span class="fc" id="L1232">        return solve(b, getNegligibleSingularValueThreshold());</span>
    }

    /**
     * This method is called internally by decompose(), and actually computes
     * Singular Value Decomposition.
     * However, algorithm implemented in this algorithm does not ensure that
     * singular values are ordered from maximal to minimal, and hence reorder()
     * method is called next within decompose() as well.
     *
     * @throws NoConvergenceException Exception thrown if singular value
     *                                estimation does not converge within provided number of maximum
     *                                iterations.
     */
    @SuppressWarnings(&quot;DuplicatedCode&quot;)
    private void internalDecompose() throws NoConvergenceException {
<span class="fc" id="L1248">        final var m = inputMatrix.getRows();</span>
<span class="fc" id="L1249">        final var n = inputMatrix.getColumns();</span>

        boolean flag;
        int i;
        int its;
        int j;
        int jj;
        int k;
<span class="fc" id="L1257">        var l = 0;</span>
<span class="fc" id="L1258">        var nm = 0;</span>
        double anorm;
        double c;
        double f;
        double g;
        double h;
        double s;
        double scale;
        double x;
        double y;
        double z;
<span class="fc" id="L1269">        var rv1 = new double[n];</span>

        // Householder reduction to bi-diagonal form
<span class="fc" id="L1272">        g = scale = anorm = 0.0;</span>
<span class="fc bfc" id="L1273" title="All 2 branches covered.">        for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1274">            l = i + 2;</span>
<span class="fc" id="L1275">            rv1[i] = scale * g;</span>
<span class="fc" id="L1276">            g = s = scale = 0.0;</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">            if (i &lt; m) {</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">                for (k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1279">                    scale += Math.abs(u.getElementAt(k, i));</span>
                }
<span class="pc bpc" id="L1281" title="1 of 2 branches missed.">                if (scale != 0.0) {</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">                    for (k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1283">                        u.setElementAt(k, i, u.getElementAt(k, i) / scale);</span>
<span class="fc" id="L1284">                        s += Math.pow(u.getElementAt(k, i), 2.0);</span>
                    }
<span class="fc" id="L1286">                    f = u.getElementAt(i, i);</span>
<span class="fc" id="L1287">                    g = -sign(Math.sqrt(s), f);</span>
<span class="fc" id="L1288">                    h = f * g - s;</span>
<span class="fc" id="L1289">                    u.setElementAt(i, i, f - g);</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">                    for (j = l - 1; j &lt; n; j++) {</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">                        for (s = 0.0, k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1292">                            s += u.getElementAt(k, i) * u.getElementAt(k, j);</span>
                        }
<span class="fc" id="L1294">                        f = s / h;</span>
<span class="fc bfc" id="L1295" title="All 2 branches covered.">                        for (k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1296">                            u.setElementAt(k, j, u.getElementAt(k, j) + f * u.getElementAt(k, i));</span>
                        }
                    }
<span class="fc bfc" id="L1299" title="All 2 branches covered.">                    for (k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1300">                        u.setElementAt(k, i, u.getElementAt(k, i) * scale);</span>
                    }
                }
            }
<span class="fc" id="L1304">            w[i] = scale * g;</span>
<span class="fc" id="L1305">            g = s = scale = 0.0;</span>
<span class="fc bfc" id="L1306" title="All 4 branches covered.">            if (i + 1 &lt;= m &amp;&amp; i + 1 != n) {</span>
<span class="fc bfc" id="L1307" title="All 2 branches covered.">                for (k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1308">                    scale += Math.abs(u.getElementAt(i, k));</span>
                }
<span class="pc bpc" id="L1310" title="1 of 2 branches missed.">                if (scale != 0.0) {</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">                    for (k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1312">                        u.setElementAt(i, k, u.getElementAt(i, k) / scale);</span>
<span class="fc" id="L1313">                        s += Math.pow(u.getElementAt(i, k), 2.0);</span>
                    }
<span class="fc" id="L1315">                    f = u.getElementAt(i, l - 1);</span>
<span class="fc" id="L1316">                    g = -sign(Math.sqrt(s), f);</span>
<span class="fc" id="L1317">                    h = f * g - s;</span>
<span class="fc" id="L1318">                    u.setElementAt(i, l - 1, f - g);</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">                    for (k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1320">                        rv1[k] = u.getElementAt(i, k) / h;</span>
                    }
<span class="fc bfc" id="L1322" title="All 2 branches covered.">                    for (j = l - 1; j &lt; m; j++) {</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">                        for (s = 0.0, k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1324">                            s += u.getElementAt(j, k) * u.getElementAt(i, k);</span>
                        }
<span class="fc bfc" id="L1326" title="All 2 branches covered.">                        for (k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1327">                            u.setElementAt(j, k, u.getElementAt(j, k) + s * rv1[k]);</span>
                        }
                    }
<span class="fc bfc" id="L1330" title="All 2 branches covered.">                    for (k = l - 1; k &lt; n; k++) {</span>
<span class="fc" id="L1331">                        u.setElementAt(i, k, u.getElementAt(i, k) * scale);</span>
                    }
                }
            }
<span class="fc" id="L1335">            anorm = Math.max(anorm, Math.abs(w[i]) + Math.abs(rv1[i]));</span>
        }

        // Accumulation of right-hand transformations
<span class="fc bfc" id="L1339" title="All 2 branches covered.">        for (i = n - 1; i &gt;= 0; i--) {</span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">            if (i &lt; (n - 1)) {</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">                if (g != 0.0) {</span>
                    // Double division to avoid possible underflow.
<span class="fc bfc" id="L1343" title="All 2 branches covered.">                    for (j = l; j &lt; n; j++) {</span>
<span class="fc" id="L1344">                        v.setElementAt(j, i, u.getElementAt(i, j) / u.getElementAt(i, l) / g);</span>
                    }
<span class="fc bfc" id="L1346" title="All 2 branches covered.">                    for (j = l; j &lt; n; j++) {</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">                        for (s = 0.0, k = l; k &lt; n; k++) {</span>
<span class="fc" id="L1348">                            s += u.getElementAt(i, k) * v.getElementAt(k, j);</span>
                        }
<span class="fc bfc" id="L1350" title="All 2 branches covered.">                        for (k = l; k &lt; n; k++) {</span>
<span class="fc" id="L1351">                            v.setElementAt(k, j, v.getElementAt(k, j) + s * v.getElementAt(k, i));</span>
                        }
                    }
                }
<span class="fc bfc" id="L1355" title="All 2 branches covered.">                for (j = l; j &lt; n; j++) {</span>
<span class="fc" id="L1356">                    v.setElementAt(i, j, 0.0);</span>
<span class="fc" id="L1357">                    v.setElementAt(j, i, 0.0);</span>
                }
            }
<span class="fc" id="L1360">            v.setElementAt(i, i, 1.0);</span>
<span class="fc" id="L1361">            g = rv1[i];</span>
<span class="fc" id="L1362">            l = i;</span>
        }

        // Accumulation of left-hand transformations
<span class="fc bfc" id="L1366" title="All 2 branches covered.">        for (i = Math.min(m, n) - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1367">            l = i + 1;</span>
<span class="fc" id="L1368">            g = w[i];</span>
<span class="fc bfc" id="L1369" title="All 2 branches covered.">            for (j = l; j &lt; n; j++) {</span>
<span class="fc" id="L1370">                u.setElementAt(i, j, 0.0);</span>
            }
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">            if (g != 0.0) {</span>
<span class="fc" id="L1373">                g = 1.0 / g;</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">                for (j = l; j &lt; n; j++) {</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                    for (s = 0.0, k = l; k &lt; m; k++) {</span>
<span class="fc" id="L1376">                        s += u.getElementAt(k, i) * u.getElementAt(k, j);</span>
                    }
<span class="fc" id="L1378">                    f = (s / u.getElementAt(i, i)) * g;</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">                    for (k = i; k &lt; m; k++) {</span>
<span class="fc" id="L1380">                        u.setElementAt(k, j, u.getElementAt(k, j) + f * u.getElementAt(k, i));</span>
                    }
                }
<span class="fc bfc" id="L1383" title="All 2 branches covered.">                for (j = i; j &lt; m; j++) {</span>
<span class="fc" id="L1384">                    u.setElementAt(j, i, u.getElementAt(j, i) * g);</span>
                }
            } else {
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                for (j = i; j &lt; m; j++) {</span>
<span class="nc" id="L1388">                    u.setElementAt(j, i, 0.0);</span>
                }
            }
<span class="fc" id="L1391">            u.setElementAt(i, i, u.getElementAt(i, i) + 1.0);</span>
        }

        // Diagonalization of the bi-diagonal form: Loop over singular values and
        // over allowed iterations.
<span class="fc bfc" id="L1396" title="All 2 branches covered.">        for (k = n - 1; k &gt;= 0; k--) {</span>
<span class="pc bpc" id="L1397" title="1 of 2 branches missed.">            for (its = 0; its &lt; maxIters; its++) {</span>
<span class="fc" id="L1398">                flag = true;</span>
                // Test for splitting
                // Note that rrv1[0] is always zero
<span class="pc bpc" id="L1401" title="1 of 2 branches missed.">                for (l = k; l &gt;= 0; l--) {</span>
<span class="fc" id="L1402">                    nm = l - 1;</span>
<span class="fc bfc" id="L1403" title="All 4 branches covered.">                    if (l == 0 || Math.abs(rv1[l]) &lt;= eps * anorm) {</span>
<span class="fc" id="L1404">                        flag = false;</span>
                    }

<span class="fc bfc" id="L1407" title="All 4 branches covered.">                    if (!flag || Math.abs(w[nm]) &lt;= eps * anorm) {</span>
<span class="fc" id="L1408">                        break;</span>
                    }
                }
                // Cancellation of rv1[0] if l &gt; 1
<span class="fc bfc" id="L1412" title="All 2 branches covered.">                if (flag) {</span>
<span class="fc" id="L1413">                    c = 0.0;</span>
<span class="fc" id="L1414">                    s = 1.0;</span>
<span class="fc bfc" id="L1415" title="All 2 branches covered.">                    for (i = l; i &lt; k + 1; i++) {</span>
<span class="fc" id="L1416">                        f = s * rv1[i];</span>
<span class="fc" id="L1417">                        rv1[i] = c * rv1[i];</span>
<span class="pc bpc" id="L1418" title="1 of 2 branches missed.">                        if (Math.abs(f) &lt;= eps * anorm) {</span>
<span class="nc" id="L1419">                            break;</span>
                        }
<span class="fc" id="L1421">                        g = w[i];</span>
<span class="fc" id="L1422">                        h = pythag(f, g);</span>
<span class="fc" id="L1423">                        w[i] = h;</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">                        if (h != 0.0) {</span>
<span class="fc" id="L1425">                            h = 1.0 / h;</span>
                        } else {
<span class="nc" id="L1427">                            h = Double.MAX_VALUE;</span>
                        }
<span class="fc" id="L1429">                        c = g * h;</span>
<span class="fc" id="L1430">                        s = -f * h;</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">                        for (j = 0; j &lt; m; j++) {</span>
<span class="fc" id="L1432">                            y = u.getElementAt(j, nm);</span>
<span class="fc" id="L1433">                            z = u.getElementAt(j, i);</span>
<span class="fc" id="L1434">                            u.setElementAt(j, nm, y * c + z * s);</span>
<span class="fc" id="L1435">                            u.setElementAt(j, i, z * c - y * s);</span>
                        }
                    }
                }
<span class="fc" id="L1439">                z = w[k];</span>
                // Convergence.
<span class="fc bfc" id="L1441" title="All 2 branches covered.">                if (l == k) {</span>
                    // Singular value is made non-negative
<span class="fc bfc" id="L1443" title="All 2 branches covered.">                    if (z &lt; 0.0) {</span>
<span class="fc" id="L1444">                        w[k] = -z;</span>
<span class="fc bfc" id="L1445" title="All 2 branches covered.">                        for (j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1446">                            v.setElementAt(j, k, -v.getElementAt(j, k));</span>
                        }
                    }
                    break;
                }
<span class="pc bpc" id="L1451" title="1 of 2 branches missed.">                if (its == maxIters - 1) {</span>
<span class="nc" id="L1452">                    throw new NoConvergenceException();</span>
                }

                // Shift from bottom 2-by-2 minor.
<span class="fc" id="L1456">                x = w[l];</span>
<span class="fc" id="L1457">                nm = k - 1;</span>
<span class="fc" id="L1458">                y = w[nm];</span>
<span class="fc" id="L1459">                g = rv1[nm];</span>
<span class="fc" id="L1460">                h = rv1[k];</span>
<span class="fc" id="L1461">                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);</span>
<span class="fc" id="L1462">                g = pythag(f, 1.0);</span>
<span class="fc" id="L1463">                f = ((x - z) * (x + z) + h * ((y / (f + sign(g, f))) - h)) / x;</span>
<span class="fc" id="L1464">                c = s = 1.0;</span>
                // Next QR transformation
<span class="fc bfc" id="L1466" title="All 2 branches covered.">                for (j = l; j &lt;= nm; j++) {</span>
<span class="fc" id="L1467">                    i = j + 1;</span>
<span class="fc" id="L1468">                    g = rv1[i];</span>
<span class="fc" id="L1469">                    y = w[i];</span>
<span class="fc" id="L1470">                    h = s * g;</span>
<span class="fc" id="L1471">                    g = c * g;</span>
<span class="fc" id="L1472">                    z = pythag(f, h);</span>
<span class="fc" id="L1473">                    rv1[j] = z;</span>
<span class="pc bpc" id="L1474" title="1 of 2 branches missed.">                    if (z != 0.0) {</span>
<span class="fc" id="L1475">                        c = f / z;</span>
<span class="fc" id="L1476">                        s = h / z;</span>
                    } else {
<span class="nc" id="L1478">                        c = Math.signum(f) * Double.MAX_VALUE;</span>
<span class="nc" id="L1479">                        s = Math.signum(h) * Double.MAX_VALUE;</span>
                    }
<span class="fc" id="L1481">                    f = x * c + g * s;</span>
<span class="fc" id="L1482">                    g = g * c - x * s;</span>
<span class="fc" id="L1483">                    h = y * s;</span>
<span class="fc" id="L1484">                    y *= c;</span>
<span class="fc bfc" id="L1485" title="All 2 branches covered.">                    for (jj = 0; jj &lt; n; jj++) {</span>
<span class="fc" id="L1486">                        x = v.getElementAt(jj, j);</span>
<span class="fc" id="L1487">                        z = v.getElementAt(jj, i);</span>
<span class="fc" id="L1488">                        v.setElementAt(jj, j, x * c + z * s);</span>
<span class="fc" id="L1489">                        v.setElementAt(jj, i, z * c - x * s);</span>
                    }
<span class="fc" id="L1491">                    z = pythag(f, h);</span>
                    // Rotation can be arbitrary if z = 0
<span class="fc" id="L1493">                    w[j] = z;</span>
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">                    if (z != 0.0) {</span>
<span class="fc" id="L1495">                        z = 1.0 / z;</span>
<span class="fc" id="L1496">                        c = f * z;</span>
<span class="fc" id="L1497">                        s = h * z;</span>
                    }
<span class="fc" id="L1499">                    f = c * g + s * y;</span>
<span class="fc" id="L1500">                    x = c * y - s * g;</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                    for (jj = 0; jj &lt; m; jj++) {</span>
<span class="fc" id="L1502">                        y = u.getElementAt(jj, j);</span>
<span class="fc" id="L1503">                        z = u.getElementAt(jj, i);</span>
<span class="fc" id="L1504">                        u.setElementAt(jj, j, y * c + z * s);</span>
<span class="fc" id="L1505">                        u.setElementAt(jj, i, z * c - y * s);</span>
                    }
                }
<span class="fc" id="L1508">                rv1[l] = 0.0;</span>
<span class="fc" id="L1509">                rv1[k] = f;</span>
<span class="fc" id="L1510">                w[k] = x;</span>
            }
        }
<span class="fc" id="L1513">    }</span>

    /**
     * Reorders singular values from maximal to minimal, and also reorders
     * columns and rows of U and V to ensure that Singular Value Decomposition
     * still remains valid.
     */
    private void reorder() {
<span class="fc" id="L1521">        final var m = inputMatrix.getRows();</span>
<span class="fc" id="L1522">        final var n = inputMatrix.getColumns();</span>

        int i;
        int j;
        int k;
        int s;
<span class="fc" id="L1528">        var inc = 1;</span>
        double sw;
<span class="fc" id="L1530">        final var su = new double[m];</span>
<span class="fc" id="L1531">        final var sv = new double[n];</span>

        do {
<span class="fc" id="L1534">            inc *= 3;</span>
<span class="fc" id="L1535">            inc++;</span>
<span class="fc bfc" id="L1536" title="All 2 branches covered.">        } while (inc &lt;= n);</span>
        do {
<span class="fc" id="L1538">            inc /= 3;</span>
<span class="fc bfc" id="L1539" title="All 2 branches covered.">            for (i = inc; i &lt; n; i++) {</span>
<span class="fc" id="L1540">                sw = w[i];</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">                for (k = 0; k &lt; m; k++) {</span>
<span class="fc" id="L1542">                    su[k] = u.getElementAt(k, i);</span>
                }
<span class="fc bfc" id="L1544" title="All 2 branches covered.">                for (k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L1545">                    sv[k] = v.getElementAt(k, i);</span>
                }
<span class="fc" id="L1547">                j = i;</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">                while (w[j - inc] &lt; sw) {</span>
<span class="fc" id="L1549">                    w[j] = w[j - inc];</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">                    for (k = 0; k &lt; m; k++) {</span>
<span class="fc" id="L1551">                        u.setElementAt(k, j, u.getElementAt(k, j - inc));</span>
                    }
<span class="fc bfc" id="L1553" title="All 2 branches covered.">                    for (k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L1554">                        v.setElementAt(k, j, v.getElementAt(k, j - inc));</span>
                    }
<span class="fc" id="L1556">                    j -= inc;</span>
<span class="fc bfc" id="L1557" title="All 2 branches covered.">                    if (j &lt; inc) {</span>
<span class="fc" id="L1558">                        break;</span>
                    }
                }
<span class="fc" id="L1561">                w[j] = sw;</span>
<span class="fc bfc" id="L1562" title="All 2 branches covered.">                for (k = 0; k &lt; m; k++) {</span>
<span class="fc" id="L1563">                    u.setElementAt(k, j, su[k]);</span>
                }
<span class="fc bfc" id="L1565" title="All 2 branches covered.">                for (k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L1566">                    v.setElementAt(k, j, sv[k]);</span>
                }
            }
<span class="fc bfc" id="L1569" title="All 2 branches covered.">        } while (inc &gt; 1);</span>

<span class="fc bfc" id="L1571" title="All 2 branches covered.">        for (k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L1572">            s = 0;</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">            for (i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L1574" title="All 2 branches covered.">                if (u.getElementAt(i, k) &lt; 0.0) {</span>
<span class="fc" id="L1575">                    s++;</span>
                }
            }
<span class="fc bfc" id="L1578" title="All 2 branches covered.">            for (j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">                if (v.getElementAt(j, k) &lt; 0.0) {</span>
<span class="fc" id="L1580">                    s++;</span>
                }
            }
<span class="fc bfc" id="L1583" title="All 2 branches covered.">            if (s &gt; (m + n) / 2) {</span>
<span class="fc bfc" id="L1584" title="All 2 branches covered.">                for (i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L1585">                    u.setElementAt(i, k, -u.getElementAt(i, k));</span>
                }
<span class="fc bfc" id="L1587" title="All 2 branches covered.">                for (j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1588">                    v.setElementAt(j, k, -v.getElementAt(j, k));</span>
                }
            }
        }
<span class="fc" id="L1592">    }</span>

    /**
     * Sets threshold to be used to determine whether a singular value is
     * negligible or not.
     * This threshold can be used to consider a singular value as zero or not,
     * since small singular values might appear in places where they should be
     * zero because of rounding errors and machine precision.
     * Singular values considered as zero determine aspects such as rank,
     * nullability, null-space or range space.
     *
     * @param threshold Threshold to be used to determine whether a singular
     *                  value is negligible or not.
     */
    private void setNegligibleSingularValueThreshold(final double threshold) {
<span class="fc" id="L1607">        tsh = threshold;</span>
<span class="fc" id="L1608">    }</span>

    /**
     * Computes norm of a vector of 2 components 'a' and 'b' as
     * sqrt(pow(a, 2.0)  + pow(b, 2.0)) without destructive underflow or
     * overflow, that is when a or b are close to maximum or minimum values
     * allowed by machine precision, computing the previous expression might
     * lead to highly inaccurate results.
     * This method implements previous expression to avoid this effect as
     * much as possible and increase accuracy.
     *
     * @param a 1st value
     * @param b 2nd value
     * @return Norm of (a, b).
     */
    private double pythag(final double a, final double b) {
<span class="fc" id="L1624">        final var absa = Math.abs(a);</span>
<span class="fc" id="L1625">        final var absb = Math.abs(b);</span>

<span class="fc bfc" id="L1627" title="All 2 branches covered.">        if (absa &gt; absb) {</span>
<span class="fc" id="L1628">            return absa * Math.sqrt(1.0 + (absb / absa) * (absb / absa));</span>
        } else {
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">            return (absb == 0.0 ? 0.0 : absb * Math.sqrt(1.0 + (absa / absb) * (absa / absb)));</span>
        }
    }

    /**
     * Returns a or -a depending on b sign. If b is positive, this method
     * returns &quot;a&quot;, otherwise it returns -a
     *
     * @param a 1st value
     * @param b 2nd value
     * @return a or -a depending on b sign.
     */
    private double sign(final double a, final double b) {
<span class="fc bfc" id="L1643" title="All 2 branches covered.">        if (b &gt;= 0.0) {</span>
<span class="pc bpc" id="L1644" title="1 of 2 branches missed.">            return a &gt;= 0.0 ? a : -a;</span>
        } else {
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">            return a &gt;= 0.0 ? -a : a;</span>
        }
    }

    /**
     * Internal method to copy range space vector values into provided matrix.
     * Provided matrix will be resized if needed
     *
     * @param rank                   Rank of range space
     * @param singularValueThreshold Threshold to determine whether a singular
     *                               value is null
     * @param range                  Matrix where range space vector values are stored.
     */
    private void internalGetRange(final int rank, final double singularValueThreshold, final Matrix range) {
<span class="fc" id="L1660">        final var rows = inputMatrix.getRows();</span>
<span class="fc" id="L1661">        final var columns = inputMatrix.getColumns();</span>

<span class="pc bpc" id="L1663" title="1 of 4 branches missed.">        if (range.getRows() != rows || range.getColumns() != rank) {</span>
            try {
<span class="fc" id="L1665">                range.resize(rows, rank);</span>
<span class="nc" id="L1666">            } catch (final WrongSizeException ignore) {</span>
                // never happens
<span class="fc" id="L1668">            }</span>
        }

<span class="fc" id="L1671">        var nr = 0;</span>
<span class="fc bfc" id="L1672" title="All 2 branches covered.">        for (var j = 0; j &lt; columns; j++) {</span>
<span class="fc bfc" id="L1673" title="All 2 branches covered.">            if (w[j] &gt; singularValueThreshold) {</span>
                // copy column j of U matrix into column nr of out matrix
<span class="fc" id="L1675">                range.setSubmatrix(0, nr, rows - 1, nr, u, 0, j,</span>
                        rows - 1, j);
<span class="fc" id="L1677">                nr++;</span>
            }
        }
<span class="fc" id="L1680">    }</span>

    /**
     * Internal method to copy null-space vector values into provided matrix.
     * Provided matrix will be resized if needed
     *
     * @param nullity                Nullity of null-space
     * @param singularValueThreshold Threshold to determine whether a singular
     *                               value is null
     * @param nullspace              Matrix where null-space vector values are stored.
     */
    private void internalGetNullspace(final int nullity, final double singularValueThreshold,
                                      final Matrix nullspace) {
<span class="fc" id="L1693">        final int columns = inputMatrix.getColumns();</span>

<span class="pc bpc" id="L1695" title="1 of 4 branches missed.">        if (nullspace.getRows() != columns || nullspace.getColumns() != nullity) {</span>
            try {
<span class="fc" id="L1697">                nullspace.resize(columns, nullity);</span>
<span class="nc" id="L1698">            } catch (final WrongSizeException ignore) {</span>
                // never happens
<span class="fc" id="L1700">            }</span>
        }

<span class="fc" id="L1703">        var nn = 0;</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        for (var j = 0; j &lt; columns; j++) {</span>
<span class="fc bfc" id="L1705" title="All 2 branches covered.">            if (w[j] &lt;= singularValueThreshold) {</span>
                // copy column j of U matrix into column nn of out matrix
<span class="fc" id="L1707">                nullspace.setSubmatrix(0, nn, columns - 1, nn, v, 0, j,</span>
                        columns - 1, j);
<span class="fc" id="L1709">                nn++;</span>
            }
        }
<span class="fc" id="L1712">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>